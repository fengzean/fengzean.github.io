<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>e^iπ+1=0</title>
  <icon>https://www.gravatar.com/avatar/a037ef79991843da81c55592a84da779</icon>
  <subtitle>Prevention is better than cure!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.littlefeng.com/"/>
  <updated>2018-09-26T16:29:47.303Z</updated>
  <id>https://www.littlefeng.com/</id>
  
  <author>
    <name>Frazer</name>
    <email>frazer0917@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一张图搞定OSI模型</title>
    <link href="https://www.littlefeng.com/2018/09/27/OSI/"/>
    <id>https://www.littlefeng.com/2018/09/27/OSI/</id>
    <published>2018-09-27T13:30:00.000Z</published>
    <updated>2018-09-26T16:29:47.303Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p><img src="/assets/blogImg/OSI.jpg" alt=""></p><a id="more"></a><h3 id="相关协议-缩写"><a href="#相关协议-缩写" class="headerlink" title="相关协议 缩写"></a>相关协议 缩写</h3><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>HTTP 超文本传输协议<br>FTP 文件传输协议<br>SMTP 简单邮件传输协议<br>ELNET TCP/IP终端仿真协议<br>POP3 邮局协议第三版<br>Finger 用户信息协议<br>NNTP 网络新闻传输协议<br>IMAP4 因特网信息访问协议第四版<br>LPR UNIX 远程打印协议<br>Rwho UNIX 远程 Who协议<br>Rexec UNIX远程执行协议<br>Login UNIX 远程登陆协议<br>RSH UNIX 远程Shell协议<br>NTF HP网络文件传输协议<br>RDA HP 远程数据库访问协议<br>VT 虚拟终端仿真协议<br>RFA HP 远程文件访问协议<br>RPC Remote Process Comm.<br>S-HTTP 安全超文本传输协议<br>GDP网关发现协议<br>X-Window<br>CMOT 基于TCP/IP的CMIP协议<br>SOCKS 安全套接字协议<br>FANP流属性通知协议<br>SLP服务定位协议<br>MSN微软网络服务<br>Radius 远程用户拨号认证服务协议<br>DNS 域名系统<br>NFS网络文件系统协议<br>NIS SUN 网络信息系统协议<br>R-STAT SUN远程状态协议<br>NSM SUN 网络状态监测协议<br>PMAP SUN 端口映射协议<br>Mount<br>LPR UNIX远程打印协议<br>常用UDP协议的应用层服务<br>BOOTP引导协议<br>DHCP动态主机配套协议<br>NTP网络时间协议<br>TFTP简单文件传输协议<br>SNMP简单网络管理协议</p><h4 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h4><p>DECnet NSP<br>LPP 轻量级表示协议<br>NBSSN NetBIOS会话服务协议<br>XDP外部数据表示协议<br>IPX</p><h4 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h4><p>SSL 安全套接字层协议<br>TLS传输层安全协议<br>DAP目录访问协议<br>LDAP轻量级目录访问协议<br>RPC远程过程调用协议<br>VINES NETRPC<br>VFRP<br>NeTBIOS<br>IPX</p><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>XOT 基于tcp之上的X协议<br>Van Jacobson 压缩TCP协议<br>ISO-DE ISO 开发环境——–&gt;NetBISO<br>TALI 传输适配层接口协议<br>DSI、NetBIOS、IP NeTBIOS、ISO-TP SSP、SMB、MSRPC<br>UDP用户数据报协议<br>RUDP可靠的用户数据报协议<br>Mobile IP 移动IP协议</p><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>IP/IPv6 互联网协议/互联网协议第六版<br>ICMPv6互联网控制信息协议第六版<br>ICMP互联网控制信息协议<br>IGMP 互联网组管理协议<br>SLIP 串行线路IP协议<br>安全协议<br>AH 认证头协议<br>ESP 安装封装有效载荷协议<br>路由协议<br>EGP 外部网关协议<br>OSPF 开放最短路径优先协议<br>IGRP 内部网关路由协议<br>NHRP 下一跳解析协议<br>IE-IRGP 增强内部网关路由选择协议<br>RIPng for IPv6 IPv6路由信息协议<br>GGP 网关到网关协议<br>VRRP 虚拟路由器冗余协议<br>PGM 实际通用组播协议<br>RSVP 资源预留协议<br>PIM-DM 密集模式独立组播协议<br>DVMRP 距离矢量组播路由协议<br>RIP2 路由信息协议第二版<br>PIM-SM 稀疏模式独立组播协议<br>MOSPF 组播开放最短路径优先协议</p><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>MPLS 多协议标签交换协议<br>XTP 压缩传输协议<br>DCAP 数据转换客户访问协议<br>SLE 串行连接封装协议<br>IPinIP IP套IP封装协议<br>隧道协议<br>PPTP点对点隧道协议<br>L2F第二层转发协议<br>L2TP 第二层隧道协议<br>ATMP接入隧道管理协议<br>Cisco 协议<br>CDP 思科发现协议<br>CGMP 思科组管理协议<br>地址解析协议<br>ARP地址解析协议<br>RAR逆向地址解析协议</p><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>IEEE 802.2<br>Ethernet v.2<br>Internetwork</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;OSI七层模型&quot;&gt;&lt;a href=&quot;#OSI七层模型&quot; class=&quot;headerlink&quot; title=&quot;OSI七层模型&quot;&gt;&lt;/a&gt;OSI七层模型&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/assets/blogImg/OSI.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="tcp/ip" scheme="https://www.littlefeng.com/categories/tcp-ip/"/>
    
    
  </entry>
  
  <entry>
    <title>SSL/TLS认证申请踩坑记</title>
    <link href="https://www.littlefeng.com/2018/09/25/SSL%E8%AE%A4%E8%AF%81%E7%94%B3%E8%AF%B7%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
    <id>https://www.littlefeng.com/2018/09/25/SSL认证申请踩坑记/</id>
    <published>2018-09-25T13:30:00.000Z</published>
    <updated>2018-09-24T15:52:53.412Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=22789069&auto=0&height=66"></iframe><h3 id="1-SSL-TLS证书简介（摘自维基百科）"><a href="#1-SSL-TLS证书简介（摘自维基百科）" class="headerlink" title="1.SSL/TLS证书简介（摘自维基百科）"></a>1.SSL/TLS证书简介（摘自维基百科）</h3><p><img src="/assets/blogImg/scure.jpg" alt=""></p><p><strong>传输层安全性协议</strong>（英语：Transport Layer Security，<a href="https://zh.wikipedia.org/wiki/%E7%B8%AE%E5%AF%AB" target="_blank" rel="noopener">缩写</a>作 <strong>TLS</strong>），及其前身<strong>安全套接层</strong>（Secure Sockets Layer，缩写作 <strong>SSL</strong>）是一种<a href="https://zh.wikipedia.org/wiki/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">安全协议</a>，目的是为<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E9%9A%9B%E7%B6%B2%E8%B7%AF" target="_blank" rel="noopener">互联网</a>通信，提供安全及数据<a href="https://zh.wikipedia.org/wiki/%E5%AE%8C%E6%95%B4%E6%80%A7" target="_blank" rel="noopener">完整性</a>保障。<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E6%99%AF" target="_blank" rel="noopener">网景</a>公司（Netscape）在1994年推出首版<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E9%A0%81%E7%80%8F%E8%A6%BD%E5%99%A8" target="_blank" rel="noopener">网页浏览器</a>，<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E6%99%AF%E9%A0%98%E8%88%AA%E5%93%A1" target="_blank" rel="noopener">网景导航者</a>时，推出<a href="https://zh.wikipedia.org/wiki/HTTPS" target="_blank" rel="noopener">HTTPS</a>协议，以SSL进行加密，这是SSL的起源。<a href="https://zh.wikipedia.org/wiki/IETF" target="_blank" rel="noopener">IETF</a>将SSL进行标准化，1999年公布第一版TLS标准文件。随后又公布RFC 5246 （2008年8月）与 <a href="https://tools.ietf.org/html/rfc6176" target="_blank" rel="noopener">RFC 6176</a> （2011年3月）。在<a href="https://zh.wikipedia.org/wiki/%E7%80%8F%E8%A6%BD%E5%99%A8" target="_blank" rel="noopener">浏览器</a>、<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%AD%90%E9%83%B5%E4%BB%B6" target="_blank" rel="noopener">电子邮件</a>、<a href="https://zh.wikipedia.org/wiki/%E5%8D%B3%E6%99%82%E9%80%9A%E8%A8%8A" target="_blank" rel="noopener">即时通信</a>、<a href="https://zh.wikipedia.org/wiki/VoIP" target="_blank" rel="noopener">VoIP</a>、<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E7%B5%A1%E5%82%B3%E7%9C%9F" target="_blank" rel="noopener">网络传真</a>等应用程序中，广泛支持这个协议。主要的网站，如<a href="https://zh.wikipedia.org/wiki/Google" target="_blank" rel="noopener">Google</a>、<a href="https://zh.wikipedia.org/wiki/Facebook" target="_blank" rel="noopener">Facebook</a>等也以这个协议来创建安全连线，发送数据。目前已成为<a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91" target="_blank" rel="noopener">互联网</a>上保密通信的工业标准。</p><a id="more"></a><p>SSL包含记录层（Record Layer）和传输层，记录层协议确定传输层数据的封装格式。传输层安全协议使用<a href="https://zh.wikipedia.org/wiki/X.509" target="_blank" rel="noopener">X.509</a>认证，之后利用非对称加密演算来对通信方做身份认证，之后交换对称密钥作为会谈密钥（<a href="https://zh.wikipedia.org/wiki/Session_key" target="_blank" rel="noopener">Session key</a>）。这个会谈密钥是用来将通信两方交换的数据做加密，保证两个应用间通信的保密性和可靠性，使客户与服务器应用之间的通信不被攻击者窃听。</p><h3 id="2-遇到的问题"><a href="#2-遇到的问题" class="headerlink" title="2.遇到的问题"></a>2.遇到的问题</h3><p>由于网页代码托管平台的关系（国内托管于coding，国外托管于github），在github上先完成托管，因此 DNS 的 CNAME 记录先设置为将域名解析到<code>github.io</code>，同时域名启用https解析（github不支持SSL证书上传），步骤和详情<a href="https://help.github.com/articles/securing-your-github-pages-site-with-https/" target="_blank" rel="noopener">请戳</a>，coding托管是后来完成的，此时也想让coding的静态 Pages 应用(<code>coding.me</code>)启用https协议，同时申请SSL/TLS 安全证书，这是问题出现了，SSL证书死活申请不成功，主要是半小时才能申请一次，其实也有技巧，报错信息为：</p><blockquote><p>urn:acme:error:unauthorized:Invalid response from <a href="http://exmaple.com/.well-known/acme-challenge/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" target="_blank" rel="noopener">http://exmaple.com/.well-known/acme-challenge/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</a>: xxxxxxxxx</p></blockquote><p>，同时在<a href="https://ziyuan.baidu.com/?castk=LTE%3D" target="_blank" rel="noopener">百度长站</a>提交的htpps认证也不成功，抓取诊断（抓取UA分别为PC和移动）均处出现抓取失败，如下：</p><p><img src="/assets/blogImg/PUA.png" alt=""></p><p>出现了拒绝访问的情形。</p><h3 id="3-分析原因"><a href="#3-分析原因" class="headerlink" title="3.分析原因"></a>3.分析原因</h3><p>根据上面错误的情形，google了一下，发现了Coding Pages的官方文件：<a href="https://coding.net/help/faq/pages/coding-pages-faq.html" target="_blank" rel="noopener">Coding Pages 常见问题</a></p><p>这时候按照官方文件的指引，找到了和我一样的错误信息的解决方案：</p><blockquote><p>错误原因：无法获取正确的域名验证信息<br>解决方式1：检查 DNS 的 CNAME 记录是否设置正确，静态 Pages 为 <code>pages.coding.me</code>，动态 Pages 为 <code>pages.coding.io</code><br>解决方式2：检查域名的 DNS 是否将海外线路解析到 Coding Pages 的服务器</p></blockquote><p>由于Coding Pages的静态Pages是免费的，于是解决方式1对我来说就不存在了，接着联想到之前我对部署在GitHub Pages上的个人站点进行了自定义域名绑定+域名解析设置，有些豁然开朗的感觉。由于我的个人站点是同时部署到GitHub 和Coding 上，接着在腾讯域名解析里进行了配置：国内的解析线路将我的域名指向<code>coding.me</code>，默认的解析路线则是指向了<code>github.io</code>。</p><p>之所以这样配置，是因为国内部分地区无法直接访问GitHub（百度的spider也无法爬取github的内容，然而google就厉害得多了），自然就无法访问我托管在GitHub上的网页代码，于是我又选择了Codingt的静态Pages服务，这样国内用户就可以快速访问到我托管在Coding 的网页代码，而国外用户则是快速访问到github上的网页代码。</p><p>问题就出现在这里，因为在申请coding的请SSL/TLS证书之前，已有对github的国外解析路线，同时申请时候直接解析了国外线路，导致在Coding 的后台在申请证书时无法通过验证，自然就申请失败了。</p><p>因此解决该问题应该用上述的解决方式2。</p><h3 id="4-解决方法"><a href="#4-解决方法" class="headerlink" title="4.解决方法"></a>4.解决方法</h3><p><img src="/assets/blogImg/DNS解析.png" alt=""></p><p>登陆到腾讯云域名解析的后台系统，打开个人域名的解析设置，暂停对于上图红框内所有线路的解析，然后大概需要10分钟左右的生效时间，毕竟DNS解析是存在缓存的。10分钟后进入Coding 静态 Pages 应用服务的后台，再一次申请SSL/TLS证书，果不其然，几秒钟后申请证书成功。</p><p><img src="/assets/blogImg/SSL.png" alt=""></p><p>最后，再次返回腾讯云域名解析的后台，将红框内的线路再次启用，顺利解决。此时去申请百度长站的https认证也成功了，抓取数据也ok了。</p><p><img src="/assets/blogImg/httpsBAidu.png" alt=""></p><p>总结：先关掉国外的线路解析，然后申请SSL证书，成功后再启用之前关掉的线路。</p>]]></content>
    
    <summary type="html">
    
      &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=22789069&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;

&lt;h3 id=&quot;1-SSL-TLS证书简介（摘自维基百科）&quot;&gt;&lt;a href=&quot;#1-SSL-TLS证书简介（摘自维基百科）&quot; class=&quot;headerlink&quot; title=&quot;1.SSL/TLS证书简介（摘自维基百科）&quot;&gt;&lt;/a&gt;1.SSL/TLS证书简介（摘自维基百科）&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/assets/blogImg/scure.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;传输层安全性协议&lt;/strong&gt;（英语：Transport Layer Security，&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%B8%AE%E5%AF%AB&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;缩写&lt;/a&gt;作 &lt;strong&gt;TLS&lt;/strong&gt;），及其前身&lt;strong&gt;安全套接层&lt;/strong&gt;（Secure Sockets Layer，缩写作 &lt;strong&gt;SSL&lt;/strong&gt;）是一种&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;安全协议&lt;/a&gt;，目的是为&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%B6%B2%E9%9A%9B%E7%B6%B2%E8%B7%AF&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;互联网&lt;/a&gt;通信，提供安全及数据&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%AE%8C%E6%95%B4%E6%80%A7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;完整性&lt;/a&gt;保障。&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%B6%B2%E6%99%AF&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;网景&lt;/a&gt;公司（Netscape）在1994年推出首版&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%B6%B2%E9%A0%81%E7%80%8F%E8%A6%BD%E5%99%A8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;网页浏览器&lt;/a&gt;，&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%B6%B2%E6%99%AF%E9%A0%98%E8%88%AA%E5%93%A1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;网景导航者&lt;/a&gt;时，推出&lt;a href=&quot;https://zh.wikipedia.org/wiki/HTTPS&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HTTPS&lt;/a&gt;协议，以SSL进行加密，这是SSL的起源。&lt;a href=&quot;https://zh.wikipedia.org/wiki/IETF&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IETF&lt;/a&gt;将SSL进行标准化，1999年公布第一版TLS标准文件。随后又公布RFC 5246 （2008年8月）与 &lt;a href=&quot;https://tools.ietf.org/html/rfc6176&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RFC 6176&lt;/a&gt; （2011年3月）。在&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%80%8F%E8%A6%BD%E5%99%A8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;浏览器&lt;/a&gt;、&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%AD%90%E9%83%B5%E4%BB%B6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;电子邮件&lt;/a&gt;、&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8D%B3%E6%99%82%E9%80%9A%E8%A8%8A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;即时通信&lt;/a&gt;、&lt;a href=&quot;https://zh.wikipedia.org/wiki/VoIP&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;VoIP&lt;/a&gt;、&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%B6%B2%E7%B5%A1%E5%82%B3%E7%9C%9F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;网络传真&lt;/a&gt;等应用程序中，广泛支持这个协议。主要的网站，如&lt;a href=&quot;https://zh.wikipedia.org/wiki/Google&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Google&lt;/a&gt;、&lt;a href=&quot;https://zh.wikipedia.org/wiki/Facebook&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Facebook&lt;/a&gt;等也以这个协议来创建安全连线，发送数据。目前已成为&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;互联网&lt;/a&gt;上保密通信的工业标准。&lt;/p&gt;
    
    </summary>
    
      <category term="tcp/ip" scheme="https://www.littlefeng.com/categories/tcp-ip/"/>
    
      <category term="https" scheme="https://www.littlefeng.com/categories/tcp-ip/https/"/>
    
    
  </entry>
  
  <entry>
    <title>关于Google神牛Jeff Dean的笑话，非程序员勿入</title>
    <link href="https://www.littlefeng.com/2018/09/24/%E5%85%B3%E4%BA%8EGoogle%E7%A5%9E%E7%89%9BJeff%20Dean%E7%9A%84%E7%AC%91%E8%AF%9D%EF%BC%8C%E9%9D%9E%E7%A8%8B%E5%BA%8F%E5%91%98%E5%8B%BF%E5%85%A5/"/>
    <id>https://www.littlefeng.com/2018/09/24/关于Google神牛Jeff Dean的笑话，非程序员勿入/</id>
    <published>2018-09-24T15:43:44.816Z</published>
    <updated>2018-09-24T15:43:44.816Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>﻿关于<a href="http://research.google.com/people/jeff/" target="_blank" rel="noopener">Jeff Dean</a>:，简单来说，这货是Google牛逼的源泉之一。因为此人实在太牛了，于是出现了关于他有多牛的几个笑话，直接笑翻，和大家共享下。<br><a id="more"></a></p><ol><li><p>During his own Google interview, Jeff Dean was asked the  implications if P=NP were true.  He said, “P = 0 or N = 1.” Then, before  the interviewer had even finished laughing, Jeff examined Google’s  public certificate and wrote the private key on the whiteboard.<br> 当他被Google面试时，Jeff Dean被问及如果P=NP意味着什么。他说，“P=0 或者 N=1”。然后，在所有的面试官还没笑完之前，Jeff瞄了一眼Google的公共证书然后在白板上写上了对应的私钥。</p></li><li><p>Compilers don’t warn Jeff Dean.   Jeff Dean warns compilers.<br> 编译器从来不给Jeff编译警告，而是Jeff警告编译器</p></li><li><p>The rate at which Jeff Dean produces code jumped by a factor of 40  in late 2000 when he upgraded his keyboard to USB 2.0.<br> 在2000年后段，Jeff码代码的速度突然激增了40倍，原因是他把自己的键盘升级到了USB 2.0</p></li><li><p>Jeff Dean builds his code before committing it, but only to check for compiler and linker bugs.<br> Jeff还是会在提交代码前把它们编译一遍，不过这么做的目的只是为了检查下编译器和链接器有没有bug</p></li><li><p>All pointers point to Jeff Dean.<br> 所有指针都是指向Jeff的</p></li><li><p>gcc -O4 emails your code to Jeff Dean for a rewrite.<br> gcc的-O4优化选项是将你的代码邮件给Jeff重写一下</p></li><li><p>The speed of light in a vacuum used to be about 35 mph. Then Jeff Dean spent a weekend optimizing physics.<br> 光在真空中的速度曾近是35英里每小时，后来Jeff花了一个周末对物理学进行了小小的优化</p></li><li><p>Jeff Dean was born on December 31, 1969 at 11:48 PM. It took him twelve minutes to implement his first time counter.<br> Jeff出生于1969年12月31日的下午11点48分，然后他花了整整12分钟的时间实现了他的第一个计时器。（背景：计算机中的计时器数值通常被设计为从1970年1月1日0点0分0秒到当前为止的秒数）</p></li><li><p>When Jeff Dean sends an ethernet frame there are no collisions because the competing frames retreat back up into the buffer memory on their source nic.<br> 当Jeff向以太网发送一个数据包时从来不会有冲突，原因是本来要和它有冲突的包都默默撤回了缓冲区</p></li><li><p>Unsatisfied with constant time, Jeff Dean created the world’s first O(1/n)algorithm.<br>Jeff对常量的时间复杂度并不满足，于是他创造了世界上第一个O(1/n)的算法。（即随着问题规模的增大，其解决问题所花的时间会越短）</p></li><li><p>Jeff Dean was forced to invent asynchronous APIs one day when he optimized a function so that it returned before it was invoked.<br>Jeff曾被迫发明了异步API，原因是经他优化后的某个函数会在调用开始前返回</p></li></ol><ol start="12"><li><p>When Jeff Dean designs software, he first codes the binary and then writes the source as documentation.<br>当Jeff写软件时，他是直接码机器码的。写源代码只是为了作为文档使用。</p></li><li><p>Jeff Dean wrote an O(n^2) algorithm once. It was for the Traveling Salesman Problem.<br>Jeff曾无奈写过一次O(n^2)的算法，其解决的问题是旅行商问题。（该问题是NPC的，即计算机中最复杂最难解决的一类问题，许多人相信这些问题是没有多项式时间复杂度的解的）</p></li><li><p>Jeff Dean can beat you at connect four. In three moves.<br>Jeff在四子连珠的游戏中能赢你，在三步内</p></li><li><p>When your code has undefined behavior, you get a seg fault and corrupted data. When Jeff Dean’s code has undefined behavior, a unicorn rides in on a rainbow and gives everybody free ice cream.<br>当你的代码有不确定行为时，你通常得到一个段错误或者不正确的数据。当Jeff的代码有不确定行为时，孙悟空会驾着七彩云朵给每个人发免费的长寿仙桃</p></li><li><p>When Jeff Dean fires up the profiler, loops unroll themselves in fear.<br>当Jeff触发程序的程序性能采样时，循环会因害怕而自动展开。</p></li><li><p>Jeff Dean is still waiting for mathematicians to discover the joke he hid in the digits of PI.<br>Jeff依然孤独地等待着数学家们解开他在PI的数字中隐藏的笑话</p></li><li><p>Jeff Dean’s keyboard has two keys: 1 and 0.<br>Jeff的键盘多达两个键：1和0</p></li><li><p>When Jeff has trouble sleeping, he Mapreduces sheep.<br>当Jeff失眠时，他Mapreduce羊群。（Mapreduce是Jeff的作品之一，这个分布式处理的框架算法是Google立足的根本之一）</p></li><li><p>When Jeff Dean listens to mp3s, he just cats them to /dev/dsp and does the decoding in his head.<br>当Jeff听MP3时，他查看其中的二进制内容然后在他脑子里进行音频解码。</p></li><li><p>When Graham Bell invented the telephone, he saw a missed call from Jeff Dean.<br>当贝爷在沙漠中逮到一个手机时，他发现手机里有个Jeff的未接来电。<br>当贝尔发明电话后，他发现电话里有个Jeff的未接来电。</p></li><li><p>Jeff Dean’s watch displays seconds since January 1st, 1970. He is never late.<br>Jeff的手表显示的数字是自1970年1月1日0点0分0秒以来的秒数，他因此从来不迟到。</p></li></ol><ol start="23"><li>Jeff starts his programming sessions with ‘cat &gt; /dev/mem’.<br>Jeff在开始编程之前，会做’cat &gt; /dev/mem’。（即把输入的内容直接导到内存中）</li></ol><ol start="24"><li><p>One day Jeff Dean grabbed his Etch-a-Sketch instead of his laptop on his way out the door. On his way back home to get his real laptop, he programmed the Etch-a-Sketch to play Tetris.<br>有一次Jeff出门时错将草图画板当笔记本拿了。结果在他回家取笔记本的路上，他对画板进行了重编程以在其上玩俄罗斯方块</p></li><li><p>Google search went down for a few hours in 2002, and Jeff Dean started handling queries by hand. Search Quality doubled.<br>在2002年，Google搜索曾挂了几个小时，于是Jeff站出来手动处理用户的查询请求。搜索准确度翻了番</p></li><li><p>The x86-64 spec includes several undocumented instructions marked ‘private use’. They are actually for Jeff Dean’s use.<br>x86-64指令集中有一些没有被记入到文档的‘私用’指令。事实上，他们是给Jeff用的</p></li><li><p>mantri@mantri-laptop~$  rm -r /<br>rm: cannot remove root directory ‘/’<br>mantri@mantri-laptop~$ su - jeffdean -c “rm -r /“<br>I am extremely sorry. Removing root directory…<br>不解释<br>//rm -r是Linux系统中删除根目录所有文件的命令，这是不可能执行的（如同在win系统中不允许格式化c盘一样），su命令是在低权限账户操作Linux系统时想执行高权限命令时使用的。</p></li><li><p>Jeff Dean once shifted a bit so hard, it ended up on another computer.<br>有次Jeff移位移得太恨了，结果那一位跑到另一台计算机上去了</p></li><li><p>Jeff Dean has gone to /dev/null and come back.<br>Jeff从/dev/null那涅槃了。（庞统啊~）<br>Jeff又从/dev/null那涅槃了。（擦！）</p></li><li><p>Jeff Dean sorts his phone contacts by their vcard’s md5 checksums.<br>Jeff通讯录的排序规则是按照联系人的md5值</p></li><li><p>Jeff Dean doesn’t kill processes, he slays them.<br>Jeff他不杀进程，他肢解虐杀它们</p></li><li><p>The needle in haystack found Jeff Dean<br>海底的针会自己找上Jeff</p></li><li><p>All of the Google App Engine is actually hosted from Jeff Dean’s Nexus S<br>Google App Engine的服务器实际上是Jeff的Nexus S</p></li><li><p>Jeff Deans’s keyboard doesn’t have a Ctrl key because nothing controls Jeff Dean.<br>Jeff的键盘压根就没有Ctrl(控制)键，因为没有什么东西能控制Jeff</p></li><li><p>You name three pointers, Einstein, Euler, and Turing, when you de-reference them, all you get is Jeff Dean.<br>如果你命名三个指针分别为爱因斯坦、欧拉和图灵，当你查看它们的指向时，你看到的都会是Jeff</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;﻿关于&lt;a href=&quot;http://research.google.com/people/jeff/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Jeff Dean&lt;/a&gt;:，简单来说，这货是Google牛逼的源泉之一。因为此人实在太牛了，于是出现了关于他有多牛的几个笑话，直接笑翻，和大家共享下。&lt;br&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://www.littlefeng.com/tags/AI/"/>
    
      <category term="google" scheme="https://www.littlefeng.com/tags/google/"/>
    
  </entry>
  
  <entry>
    <title>ARTS_week1</title>
    <link href="https://www.littlefeng.com/2018/09/24/arts_20180907_week1/"/>
    <id>https://www.littlefeng.com/2018/09/24/arts_20180907_week1/</id>
    <published>2018-09-24T15:41:47.493Z</published>
    <updated>2018-09-24T15:41:47.493Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ARTS"><a href="#ARTS" class="headerlink" title="ARTS"></a>ARTS</h1><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><hr><p>无重复字符的最长子串。<br>给定一个字符串，找出不含有重复字符的<strong>最长子串</strong>的长度。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        Set set = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>,i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n &amp;&amp; j&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(s.charAt(j)))&#123;</span><br><span class="line">                set.add(s.charAt(j));</span><br><span class="line">                j++;</span><br><span class="line">                num = Math.max(num,j-i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                set.remove(s.charAt(i));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结题思路和遇到的问题：刚一看到问题，想到用set去除重复项，最后剩下即为不重复长度，但是验证发现，这样不能保证连续。之后尝试用list存储每段不重复字符串，然后用TreeSet记录每段长度，最后去最大的数字。代码实现时，将“dvdf”保留成“vdf”不好实现，也觉得这个方法不是个好方法。</p><p>参考答案解法：<em>滑动窗口方法</em>。<br>滑动窗口是数组/字符串问题中常用的抽象概念。 窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 [i,j)[i,j)（左闭，右开）。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。例如，我们将 [i,j)[i,j)向右滑动 11 个元素，则它将变为 [i+1,j+1)[i+1,j+1)（左闭，右开）。</p><p>我们使用 HashSet 将字符存储在当前窗口 [i,j)[i,j)（最初 j=ij=i）中。 然后我们向右侧滑动索引 jj，如果它不在 HashSet 中，我们会继续滑动 jj。直到 s[j] 已经存在于 HashSet 中。此时，我们找到的没有重复字符的最长子字符串将会以索引 ii 开头。如果我们对所有的 ii 这样做，就可以得到答案。</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(2n)=O(n)O(2n)=O(n)，在最糟糕的情况下，每个字符将被 ii 和 jj 访问两次。</li><li>空间复杂度：O(min(m,n))O(min(m,n))，与之前的方法相同。滑动窗口法需要 O(k)O(k) 的空间，其中 kk 表示 <code>Set</code> 的大小。而Set的大小取决于字符串 nn 的大小以及字符集/字母 mm 的大小。 </li></ul><p>优化的滑动窗口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring2</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n =s.length(),ans = <span class="number">0</span>;</span><br><span class="line">    Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(s.charAt(j))) &#123;</span><br><span class="line">            i = Math.max(map.get(s.charAt(j)),i);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = Math.max(ans,j-i+<span class="number">1</span>);</span><br><span class="line">        map.put(s.charAt(j),j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>滑动窗口的方法最多需要执行 2n 个步骤。事实上，它可以被进一步优化为仅需要 n 个步骤。我们可以定义字符到索引的映射，而不是使用集合来判断一个字符是否存在。 当我们找到重复的字符时，我们可以立即跳过该窗口。</p><p>也就是说，如果 s[j]s[j] 在 [i,j)[i,j) 范围内有与 j′j′ 重复的字符，我们不需要逐渐增加 ii 。 我们可以直接跳过 [𝑖，𝑗][i，j′]范围内的所有元素，并将 ii 变为 j′+1j′+1。</p><hr><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>阅读文章：<a href="https://medium.com/zkcapital/the-state-of-hashing-algorithms-the-why-the-how-and-the-future-b21d5c0440de" target="_blank" rel="noopener">hash算法简介</a></p><p>文章介绍了hash算法的概念。hash算法的基本思想就是每次固定的输入生成一个固定长度的相同输出，改变一点输入将导致完全不同的输出。但是碰撞时哈希算法的一个必然问题，会有其他可能的输入导致相同的散列值。一个好的哈希算法的目标就是使攻击者极难找到生成散列值形同的输入的方法。</p><p>被广泛应用的Md5哈希，为每个输入输出一个128位的元字符串，使用一些琐碎的单向操作计算其确定性输出，但是短输出和操作的简单性使得MD5容易被打破，容易受到生日攻击。<strong>鸽巢原理：给100个鸽子和99个盒子，每个盒子上必须装上鸽子，必然有一个盒子会有两只鸽子。固定的输出约束意味着存在一定程度的排列变化，在此基础上可以发现碰撞。</strong>并且现在Md5已经有了大量泄露的前置图像。</p><p>SHA1&amp;SHA2通过增加输出长度，单向操作数量和单向操作的复杂度来改进Md5,并没有根本性的改进。SHA3是KECCAK大型哈希算法的一部分，通过一个叫做海绵构造的机制，使用随机的排列变异来吸收输入输出数据，同时作为未来输入hashing算法的一种随机性来源。</p><p>文章还介绍了比特币和Ethereum采用的哈希算法，比特币采用双重SHA256，Ethereum采用修改过的SHA3(KECCAK256)。</p><p>哈希算法的未来看起来，1）增加内部散列操作的复杂性，2）增加哈希输出的长度，希望攻击者的计算机不会快到足以有效计算碰撞。</p><hr><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>策略模式的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        File path = <span class="keyword">new</span> File(<span class="string">"/Users/yangzexu/CodeData/skyLineProjects/ThinkInJavaTest/src/com/train/io"</span>);</span><br><span class="line"></span><br><span class="line">        String[] list = path.list(<span class="keyword">new</span> DirFiltter(<span class="string">"D.*.java"</span>));<span class="comment">//策略模式，在运行时选择行为方式</span></span><br><span class="line">        <span class="keyword">for</span> (String dirItem : list)&#123;</span><br><span class="line">            System.out.println(dirItem);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirFiltter</span> <span class="keyword">implements</span> <span class="title">FilenameFilter</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Pattern pattern;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirFiltter</span><span class="params">(String regex)</span></span>&#123;</span><br><span class="line">        pattern = Pattern.compile(regex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pattern.matcher(name).matches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>File类的path方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] list(FilenameFilter filter) &#123;</span><br><span class="line">    String names[] = list();</span><br><span class="line">    <span class="keyword">if</span> ((names == <span class="keyword">null</span>) || (filter == <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> names;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; v = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; names.length ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (filter.accept(<span class="keyword">this</span>, names[i])) &#123;</span><br><span class="line">            v.add(names[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v.toArray(<span class="keyword">new</span> String[v.size()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>list()</strong>方法实现了基本的功能，并且按照<strong>FilenameFilter</strong>的形式提供了这个<strong><em>策略</em></strong>，以便完善<strong>list()</strong>在提供服务时所需要的算法。因为<strong>list()</strong>接受<strong>FilenameFilter</strong>对对象作为参数，这意味着我们可以传递实现了<strong>FilenameFilter</strong>接口的任何类的对象，用以选择（甚至在运行时）<strong>list()</strong>的行为方式。<strong>策略模式的目的就是提供了代码行为的灵活性</strong>。</p><hr><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>这周加入左耳听风，感觉自己的目标一下子就明确了。以下摘自程序员练级攻略开篇词。</p><blockquote><p>通过这一系列文章，我主要想回答以下几个问题。</p><p><strong>理论和现实的差距</strong>。你是否觉得自己从学校毕业的时候只做过小玩具一样的程序？走入职场后哪怕没有什么经验也可以把文中提到的这些课外练习走一遍。学校课程总是从理论出发，作业项目都看不出有什么实际作用，到了工作上发现自己什么也不会干。</p><p><strong>技术能力的瓶颈</strong>。你又是否觉得，在工作当中需要的技术只不过是不断地堆业务功能，完全没有什么技术含量。而你工作一段时间后，自己都感觉得非常地迷茫和彷徨，感觉到达了提高的瓶颈，完全不知道怎么提升了。</p><p><strong>技术太多学不过来</strong>。你是否又觉得，要学的技术多得都不行了，完全不知道怎么学？感觉完全跟不上。有没有什么速成的方法？</p><p>对此，我有如下的一些解释，以端正一下你的态度。</p><p>并不是理论和现实的差距大，而是你还没有找到相关的场景，来感受到那些学院派的知识的强大威力。算法与数据结构、操作系统原理、编译原理、数据库原理、计算机原理……这些原理上的东西，是你想要成为一个专家必需要学的东西。<strong>这就是“工人”和“工程师”的差别，是“建筑工人”和“建筑架构师”的差别</strong>。如果你觉得这些理论上的东西无用，那么只能说明，你只不过在从事工人的工作，而不是工程师的工作。</p><p><strong>技术能力的瓶颈，以及技术太多学不过来，只不过是你为自己的能力不足或是懒惰找的借口罢了</strong>。技术的东西都是死的，这些死的知识只要努力就是可以学会的。只不过聪明的人花得时间少，笨点的人花得时间多点罢了。这其中的时间差距主要是由学习方法的不同，基础知识储备的不同造成的。只要你的方法得当，多花点时间在基础知识上，会让你未来学习应用知识的时间大大缩短。<strong>以绝大多数人努力的程度，和为自己不努力找借口的程度为参考，只要你坚持正常的学习就可以超过大多数人</strong>了。</p><p><strong>这里没有学习技术的速成的方法，真正的牛人不是能够培训出来的，一切都是要靠你自己去努力和持续地付出</strong>。如果你觉得自己不是一个能坚持的人，也不是一个想努力的人，而是一个想找捷径的人，那么，这篇文章并不适合你。这篇文章中的成长路径是需要思考、精力和相关的经验的，这都需要时间，而且是不短的时间。你先问问自己有没有<strong>花十年磨一剑的决心</strong>，如果没有，那这篇文章对你没有任何作用。</p></blockquote><p>以下摘自 程序员面试攻略。</p><blockquote><p>要应付并通过面试并不难，但是，千万不要应付你的人生，你学技术不是用来面试的，它只是你谋生的技能，要尊重自己的谋生技能，说不定，哪天你还要用这些技能造福社会、改变世界的。</p></blockquote><p><strong>不要懒惰，脚踏实地，不要着急。用一点点的努力和持续的付出来十年磨一剑，尊重自己的谋生技能。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ARTS&quot;&gt;&lt;a href=&quot;#ARTS&quot; class=&quot;headerlink&quot; title=&quot;ARTS&quot;&gt;&lt;/a&gt;ARTS&lt;/h1&gt;&lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;无重复字符的最长子串。&lt;br&gt;给定一个字符串，找出不含有重复字符的&lt;strong&gt;最长子串&lt;/strong&gt;的长度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ARTS" scheme="https://www.littlefeng.com/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>AI100</title>
    <link href="https://www.littlefeng.com/2018/09/24/AI100/"/>
    <id>https://www.littlefeng.com/2018/09/24/AI100/</id>
    <published>2018-09-24T15:41:38.777Z</published>
    <updated>2018-09-24T15:41:38.777Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="语音和自然语言"><a href="#语音和自然语言" class="headerlink" title="语音和自然语言"></a>语音和自然语言</h1><p>人工智能带来了精致可用的人机交互方式。和其他细分领域相比，语音和自然语言处理的融资额和估值在本榜单中均属最高。<br><a id="more"></a><br>公司|国家|技术研究|产品应用|市值/估值/融资额<br>—|—|—|—|—<br>搜狗|中国|人工智能综合研究|搜索引擎、知识图谱、输入法、语音交互产品等|估值约50亿美元<br>X.AI|美国|自然语言处理|个性化智能助理|三轮融资 3.4 亿美元<br>科大讯飞|中国|语音技术和自然语言处理|输入法、教育、电信等行业解决方案|市值约 393 亿人民币<br>思必驰|中国|智能语音交互和自然对话|车载、智能家居和智能机器人等智能硬件的语音交互服务|B 轮融资 2 亿人民币<br>大象声科|中/美|声源分离、声音增强、声纹识别、麦克风阵列|会议转录、通讯、机器人、智能家居、虚拟现实、增强现实、混合现实|未透露<br>竹间智能|中国|情感对话机器人、语音情感技术、多模态情感识别|竹间个人助理机器人小影、金融机器人、客服机器人|2500万美元融资<br>TalkIQ|美国|语音识别技术、自然语言处理技术（NLP）|电话语言反馈、预测销售结果、自动信息检索|1400万美元的A轮融资<br>Solvvy|美国|智能客服|理解和分类用户请求|1200万美元的A轮融资</p><h1 id="计算机视觉"><a href="#计算机视觉" class="headerlink" title="计算机视觉"></a>计算机视觉</h1><p>计算机视觉是目前机器感知中最突出的形式。它是受到深度学习崛起影响最大的人工智能子领域，并在一些视觉任务上帮助计算机首次实现了超越人类的水平。在这个分类中，既有在动态识别方面依托于计算机视觉和深度学习技术为用户提供基于图像理解的信息获取和人机交互产品的 Clarifai ，也有充满想象力的将卫星图片和图像识别结合起来进行预测分析的 Orbital Insight 。在具体应用方面，来自英国的 Ditto Labs 和新加坡的 ViSenze 通过对计算机视觉技术的应用分别在电子商务和数字营销领域进行了一些落地实践。</p><table><thead><tr><th>公司</th><th>国家</th><th>技术研究</th><th>产品应用</th><th>市值/估值/融资额</th></tr></thead><tbody><tr><td>Clarifai</td><td>美国</td><td>计算机视觉</td><td>图像及视频识别及图像检索 API</td><td>B轮：3000 万美元</td></tr><tr><td>Affectiva</td><td>美国</td><td>计算机视觉和深度学习</td><td>实时面部表情分析和情绪识别解决方案</td><td>四轮融资 3372 万美元</td></tr><tr><td>ViSenze</td><td>新加坡</td><td>计算机视觉</td><td>电子商务、移动商务、 在线广告等图像识别解决方案</td><td>两轮融资 1400 万美元</td></tr><tr><td>Orbital Insight</td><td>美国</td><td>计算机视觉、深度学习和数据科学</td><td>分析海量卫星图像，用于经济趋势分析和公益研究</td><td>C轮融资共 5千万美元</td></tr><tr><td>Planet Labs</td><td>美国</td><td>计算机视觉和数据科学</td><td>将卫星图像识别用于农业、城市规划和灾害响应等</td><td>融资 1830万美元</td></tr><tr><td>Descartes Labs</td><td>美国</td><td>计算机视觉和深度学习</td><td>通过DLFP平台为农业提供数据分析和预测的解决方案</td><td>B轮 3千万美元</td></tr><tr><td>商汤科技</td><td>中国</td><td>计算机视觉和深度学习</td><td>人脸识别、危险品识别、行为检测、车辆检测等的安防监控系统</td><td>4.1亿美元最新融资</td></tr><tr><td>旷视科技</td><td>中国</td><td>计算机视觉和深度学习</td><td>Face++人脸识别云服务平台、Image++图像识别平台、VisionHacker移动游戏工作室</td><td>C轮4.6亿美元融资</td></tr><tr><td>依图科技</td><td>中国</td><td>计算机视觉和深度学习</td><td>基于图像理解的信息获取和人机交互服务</td><td>3.8亿元C轮融资</td></tr><tr><td>图普科技</td><td>中国</td><td>计算机视觉和深度学习</td><td>图像识别、智能审核、图片增值等云服务</td><td>新一轮千万美元融资</td></tr><tr><td>Neurala</td><td>美国</td><td>深度学习、计算机视觉</td><td>帮助机器人和智能设备学习和适应环境的软件</td><td>A轮融资约1400万美元</td></tr><tr><td>云从科技</td><td>中国</td><td>人脸识别、计算机视觉</td><td>金融机构人脸识别应用、公安系统实时布控、追逃等</td><td>B 轮 5亿人民币</td></tr></tbody></table><h1 id="芯片和硬件"><a href="#芯片和硬件" class="headerlink" title="芯片和硬件"></a>芯片和硬件</h1><p>本榜单中的芯片和硬件相关的企业主要集中于人工智能芯片和其他硬件研究。其中，来自美国的 ALCES 通过人工智能视觉算法在手机摄像头的微小尺寸上实现高清超动态的 3D 图像感知，大大提高智能机器对环境的感知水平，致力于深度学习芯片架构的 Wave Computing 则推出了自己的 DPU 。</p><table><thead><tr><th>公司</th><th>国家</th><th>技术研究</th><th>产品应用</th><th>市值/估值/融资额</th></tr></thead><tbody><tr><td>Wave Computing</td><td>美国</td><td>深度学习芯片架构</td><td>DPU (Dataflow Processing Unit)</td><td>3轮融资共5900万美元</td></tr><tr><td>Ceva</td><td>美国</td><td>人工智能芯片技术</td><td>用于机器学习的第二代神经网络软件框架 CDNN2</td><td>纳斯达克上市，市值 9.12 亿美元</td></tr><tr><td>TeraDeep</td><td>美国</td><td>基于传统的ARM和其它移动处理器平台上的深度学习算法</td><td>可以嵌入移动设备的深度学习模块</td><td>未透露</td></tr><tr><td>寒武纪科技</td><td>中国</td><td>深度学习</td><td>中国首款神经网络处理器</td><td>1亿美元 A 轮融资</td></tr><tr><td>深鉴科技</td><td>中国</td><td>神深度学习 DPU 平台</td><td>深度学习DPU平台</td><td>A+轮约4000万美元融资</td></tr><tr><td>Groq</td><td>美国</td><td>深度学习硬件、芯片</td><td>暂无信息</td><td>1030 万美元融资</td></tr><tr><td><a href="https://www.graphcore.ai/" target="_blank" rel="noopener">Graphcore</a></td><td>英国</td><td>深度学习硬件和软件开发</td><td>开源软件框架 Poplar 和「智能处理器」IPU</td><td>A轮融资 3000 万美元</td></tr></tbody></table><h1 id="智能机器"><a href="#智能机器" class="headerlink" title="智能机器"></a>智能机器</h1><p>本榜单中机器人领域的公司涵盖了中国、美国、日本、瑞士、英国、丹麦和德国等七个新老工业国家。在这个分类中，除了大型的工业级机器人，在医疗、无人机和家庭服务机器人等领域也都诞生了一批有着成熟产品和应用场景的公司，例如 Cyberdyne、3D Robotics 和 iRobot 。在静态环境中，机器人导航在很大程度上被解决了。目前的努力是在考虑如何训练机器人以泛型的、预测性的方式与周围世界进行交互。深度学习对机器人的影响也刚刚开始。</p><table><thead><tr><th>公司</th><th>国家</th><th>技术研究</th><th>产品应用</th><th>市值/估值/融资额</th></tr></thead><tbody><tr><td>ABB Robotics</td><td>瑞士</td><td>机器人及自动化技术</td><td>工业机器人、智能设备</td><td>468.95亿美元市值</td></tr><tr><td>Fanuc</td><td>日本</td><td>机器人及自动化技术</td><td>工业机器人</td><td>4.4兆日元市值</td></tr><tr><td>KUKA Robotics</td><td>德国</td><td>机器人及自动化技术</td><td>工业机器人</td><td>美的272亿美元拿下库卡94.55%的股份</td></tr><tr><td>Rethink Robotics</td><td>美国</td><td>机器人、人机交互</td><td>智能机器人</td><td>1800万美元新一轮融资</td></tr><tr><td>Universal Robots</td><td>丹麦</td><td>机器人及自动化技术</td><td>工业机器人</td><td>未透露</td></tr><tr><td>3D Robotics</td><td>美国</td><td>计算机视觉、机器人技术</td><td>无人机，软件服务</td><td>五轮融资超 1 亿 2 千 600 万美元</td></tr><tr><td>Cyberdyne</td><td>日本</td><td>可穿戴设备</td><td>医疗助理机器人</td><td>2083.56 亿日元市值</td></tr><tr><td>iRobot</td><td>美国</td><td>计算机视觉、机器人技术</td><td>电子产品，家用机器人</td><td>27亿美元市值</td></tr><tr><td>ReWalk Robotics</td><td>德国</td><td>计算机视觉、机器人技术</td><td>代步机器人，残障专用智能设备</td><td>2000万美元市值</td></tr><tr><td>Dyson</td><td>英国</td><td>智能机器，自动视觉定位及室内地图构建</td><td>清洁机器人</td><td>未透露</td></tr><tr><td>新松机器人</td><td>中国</td><td>机器人及自动化技术</td><td>工业机器人和行业解决方案</td><td>约 289 亿市值</td></tr><tr><td>埃夫特机器人</td><td>中国</td><td>机器人</td><td>工业机器人、智能装备和行业解决方案</td><td>未透露</td></tr><tr><td>大疆</td><td>中国</td><td>计算机视觉、无人机控制、环境及障碍感知、视觉跟随、自动寻路</td><td>无人机航拍和图像传输</td><td>估值约100亿美元</td></tr><tr><td>Embodied Intelligence</td><td>美国</td><td>可以接入机器人的智能模块，工厂、仓库等自动化技术</td><td>智能设备</td><td>种子轮 700 万美元融资</td></tr></tbody></table><h1 id="医疗"><a href="#医疗" class="headerlink" title="医疗"></a>医疗</h1><p>对人工智能而言，医疗领域一直被视为一个很有前景的应用领域。目前有许多依托深度学习和成像技术的人工智能创业公司，之如来自美国的基于深度学习的癌症检查公司 Enlitic 。此外，来自美国的人工智能医疗平台 CloudMedX ，以及将两大学科人工智能和基因结合起来的 Deep Genomics 。未来几年，基于人工智能的应用将能够改善数百万人的健康状况和生活质量。</p><table><thead><tr><th>公司</th><th>国家</th><th>技术研究</th><th>产品应用</th><th>市值/估值/融资额</th></tr></thead><tbody><tr><td>Arterys</td><td>美国</td><td>深度学习系统生成医疗图像</td><td>深度学习分析系统Arterys System</td><td>1200万美元A轮融资</td></tr><tr><td>Enlitic</td><td>美国</td><td>深度学习、大数据、图像检测</td><td>癌症检测系统</td><td>三轮融资 1500 万美元</td></tr><tr><td>VoxelCloud（体素科技）</td><td>美国</td><td>深度学习</td><td>医疗影像分析云服务</td><td>千万美金 A 轮融资</td></tr><tr><td>Insilico Medicine</td><td>美国</td><td>深度学习和大数据</td><td>癌症诊疗</td><td>1000万美元最新融资</td></tr><tr><td>Oncora Medical</td><td>美国</td><td>大数据和机器学习技术</td><td>通过数据分析为放射肿瘤学家提供临床决策支持，用于个性化医疗</td><td>两轮融资 132 万美元</td></tr><tr><td>Atomwise</td><td>美国</td><td>深度学习</td><td>药物发现</td><td>种子轮 630 万美元</td></tr><tr><td>TwoXAR</td><td>美国</td><td>深度学习</td><td>通过药物研发平台DUMA™来评估大型公共和私有数据集，以迅速识别药物，并对药物和疾病的匹配度按照概率进行排序</td><td>种子轮 340 万美元</td></tr><tr><td>Berg Health</td><td>美国</td><td>深度学习</td><td>Interrogative Biology® 平台结合病人生物学和人工智能分析来进行药物发现、开发和诊断等</td><td>未透露</td></tr><tr><td>CloudMedX</td><td>美国</td><td>机器学习、自然语言处理</td><td>拥有MedxExchange 、MedxInsights 和MedxCare三款服务产品的医疗人工智能平台，提供数据、医疗洞见和健康管理服务</td><td>融资 660 万美元</td></tr><tr><td>Deep Genomics</td><td>加拿大</td><td>深度学习、基因生物学</td><td>精准医疗</td><td>种子轮 370 万美元</td></tr><tr><td><a href="https://www.icarbonx.com/" target="_blank" rel="noopener">碳云智能</a></td><td>中国</td><td>大数据、人工智能</td><td>通过数据挖掘和机器分析提供个人性健康指数分析和预测</td><td>A轮融资近10亿人民币</td></tr></tbody></table><h1 id="金融"><a href="#金融" class="headerlink" title="金融"></a>金融</h1><p>由于较高的数据质量和明确的需求，金融称为人工智能最有前途的应用之一。数据分析公司 Kensho 在入侵华尔街，取代了分析师的部分工作。也出现了使用机器学习进行信用服务的 ZestFinance 和 Aire 。同时，传统金融巨头高盛也俨然变成了一家科技公司，推出基于机器学习的「AppBank」，拥有的工程师数量也接近大科技公司。</p><table><thead><tr><th>公司</th><th>国家</th><th>技术研究</th><th>产品应用</th><th>市值/估值/融资额</th></tr></thead><tbody><tr><td>Context Relevant</td><td>美国</td><td>数据挖掘、预测分析</td><td>本地分析软件和云服务</td><td>五轮融资 4430 万美元</td></tr><tr><td>Kensho Technologies</td><td>美国</td><td>机器学习、自然语言处理、数据挖掘</td><td>金融分析辅助决策系统</td><td>B 轮融资 5000 万美元（2017 年 2 月）</td></tr><tr><td>Zest Finance</td><td>美国</td><td>数据挖掘、机器学习</td><td>信用服务</td><td>四轮共 1.12 亿美元</td></tr><tr><td>Aire</td><td>英国</td><td>信用评级</td><td>金融产品的信用评级</td><td>四轮共 700 万美元</td></tr><tr><td><a href="http://www.goldmansachs.com/" target="_blank" rel="noopener">高盛</a></td><td>美国</td><td>数据挖掘、机器学习</td><td>AppBank、金融业务自动化</td><td>市值 867.10 亿美元</td></tr><tr><td><a href="https://www.antgroup.com/" target="_blank" rel="noopener">蚂蚁金服</a></td><td>中国</td><td>人工智能、数据挖掘</td><td>智能助理、信用评级和风险管理等应用</td><td>估值约 600 亿美元</td></tr><tr><td>Citadel</td><td>美国</td><td>人工智能、数据挖掘</td><td>对冲基金</td><td>目前掌管至少 260 亿美元资产</td></tr></tbody></table><h1 id="智能驾驶"><a href="#智能驾驶" class="headerlink" title="智能驾驶"></a>智能驾驶</h1><p>美国平均每⼀辆车上装有 70 个传感器，汽车将逐渐取代人类成为更好的司机，交通交由自动驾驶汽车接管，实现人与货物的实时接取和运送。这将彻底改变城市运行机制和居民生活。本榜单中自动驾驶类的公司来自美国、以色列和新加坡三个国家。除了以 Tesla 和 Drive.ai 为代表的美国公司，以色列的 Mobileye、Innoviz Technologies 以及新加坡的 nuTonomy 也分别在自动驾驶技术的视觉算法和安全系统上有着值得关注的应用。</p><table><thead><tr><th>公司</th><th>国家</th><th>技术研究</th><th>产品应用</th><th>市值/估值/融资额</th></tr></thead><tbody><tr><td><a href="https://waymo.com" target="_blank" rel="noopener">Waymo</a></td><td>美国</td><td>自动驾驶</td><td>自动驾驶汽车</td><td>谷歌无人驾驶项目开始以独立公司的身份运营</td></tr><tr><td><a href="https://www.tesla.com" target="_blank" rel="noopener">Tesla</a></td><td>美国</td><td>自动驾驶</td><td>电动汽车</td><td>498.35 亿美元市值</td></tr><tr><td><a href="https://www.drive.ai/" target="_blank" rel="noopener">Drive.ai</a></td><td>美国</td><td>深度学习</td><td>自动驾驶汽车</td><td>5000 万美元B轮融资</td></tr><tr><td><a href="http://nutonomy.com/" target="_blank" rel="noopener">nuTonomy</a></td><td>新加坡/美国</td><td>3D自动驾驶技术</td><td>城市自动驾驶的算法和软件</td><td>2轮融资公1960万美元</td></tr><tr><td>Innoviz Technologies</td><td>以色列</td><td>智能3D传感、传感器融合和精准地图和定位等核心自动驾驶技术</td><td>物美价廉的高清晰度固态激光雷达</td><td>A 轮 900 万美元融资</td></tr><tr><td>Peloton</td><td>美国</td><td>雷达和专用短程通信安全系统</td><td>自动驾驶卡车</td><td>最新一轮6000万美元融资（2017 年 4 月）</td></tr><tr><td>SmartDrive</td><td>美国</td><td>计算机视觉、数据挖掘</td><td>交通安全和表现的智能解决方案</td><td>六轮融资 1.8亿 美元</td></tr><tr><td>Zoox</td><td>美国</td><td>全自动驾驶</td><td>全新的自动驾驶汽车</td><td>3 轮融资共 2.9 亿美元</td></tr><tr><td><a href="http://www.tusimple.com/" target="_blank" rel="noopener">图森未来</a></td><td>中国</td><td>计算机视觉和深度学习</td><td>自动驾驶、图像识别SaaS服务</td><td>5500 万美金的 C 轮融资</td></tr><tr><td>Minieye</td><td>中国</td><td>计算机视觉、智能驾驶</td><td>辅助驾驶系统</td><td>A 轮数千万人民币</td></tr><tr><td><a href="https://www.argo.ai" target="_blank" rel="noopener">Argo AI</a></td><td>美国</td><td>人工智能和自动驾驶技术</td><td>自动驾驶汽车</td><td>福特将持续注资 10 亿美元</td></tr></tbody></table><h1 id="垂直应用"><a href="#垂直应用" class="headerlink" title="垂直应用"></a>垂直应用</h1><p>在垂直应用领域，我们可以看到 Uber、Airbnb 在交通路径优化和定价的人工智能应用，也有Salesforce、Slack、Sentient Technologies 将机器学习用于企业服务的经典案例。此外，在农业、法律领域的的代表公司 Planet Labs 和 ROSS Intelligence 也十分值得关注。</p><table><thead><tr><th>公司</th><th>国家</th><th>技术研究</th><th>产品应用</th><th>市值/估值/融资额</th></tr></thead><tbody><tr><td><a href="https://www.darktrace.com/" target="_blank" rel="noopener">Darktrace</a></td><td>英国</td><td>利用机器学习和独家算法来检测和响应以前未识别的网络威胁</td><td>Darktrace 的核心产品为「企业免疫系统」(EIS)</td><td>A、B、C三轮共融资1.045亿美元</td></tr><tr><td><a href="https://www.uber.com/" target="_blank" rel="noopener">Uber</a></td><td>美国</td><td>自动驾驶、机器学习、数据挖掘</td><td>自动驾驶汽车、智能交通和智能出行应用</td><td>12 轮融资 87.1 亿美元，估值 660 亿美元</td></tr><tr><td><a href="https://www.airbnb.com/" target="_blank" rel="noopener">Airbnb</a></td><td>美国</td><td>机器学习</td><td>开源 AeroSolve机器学习框架、智能助手、智能推荐、定价</td><td>9 轮融资 20 亿 9 千万美元</td></tr><tr><td><a href="https://www.salesforce.com/" target="_blank" rel="noopener">Salesforce</a></td><td>美国</td><td>云计算、深度学习、数据处理</td><td>CRM 解决方案</td><td>市值约 638.37 亿美元</td></tr><tr><td><a href="https://slack.com/" target="_blank" rel="noopener">Slack</a></td><td>美国</td><td>机器学习</td><td>企业通讯应用，bots平台</td><td>总融资 5.4 亿美元，估值约 38 亿美元</td></tr><tr><td><a href="http://www.sentient.ai/" target="_blank" rel="noopener">Sentient Technologies</a></td><td>美国</td><td>人工智能、大规模分布式计算</td><td>解决复杂商业问题的综合智能系统</td><td>1.03 亿美元 C 轮融资，三轮共 1.3578 亿美元</td></tr><tr><td><a href="https://www.dataminr.com/" target="_blank" rel="noopener">Dataminr</a></td><td>美国</td><td>数据挖掘</td><td>基于社交网络的数据分析服务</td><td>1.3 亿美元 D 轮融资。五轮共 1.83 亿美元</td></tr><tr><td><a href="http://www.rossintelligence.com/" target="_blank" rel="noopener">ROSS Intelligence</a></td><td>美国</td><td>认知计算、深度学习、自然语言处理</td><td>法务研究智能辅助工具</td><td>未透露</td></tr><tr><td><a href="http://www.xiaojukeji.com/" target="_blank" rel="noopener">滴滴</a></td><td>中国</td><td>自动驾驶、机器学习、数据挖掘</td><td>自动驾驶汽车、智能交通和智能出行应用</td><td>超55亿美元新一轮融资 （2017 年 4 月）</td></tr><tr><td><a href="https://www.toutiao.com/" target="_blank" rel="noopener">今日头条</a></td><td>中国</td><td>深度学习、自然语言处理、图像识别</td><td>媒体产品的应用</td><td>估值约 120 亿美元</td></tr><tr><td><a href="http://www.horizon-robotics.com/" target="_blank" rel="noopener">地平线机器人</a></td><td>中国</td><td>基于云端的深度神经网络算法、图像、语音、自然语言理解和运动控制、技术集成</td><td>智能机器解决方案</td><td>A+ 轮数千万美元</td></tr><tr><td><a href="https://www.cylance.com/" target="_blank" rel="noopener">Cylance</a></td><td>美国</td><td>机器学习、数据科学</td><td>使用人工智能来预防网络攻击</td><td>已融资 1.77 亿美元</td></tr><tr><td><a href="https://siftscience.com/" target="_blank" rel="noopener">Sift Science</a></td><td>美国</td><td>机器学习</td><td>利用人工智能/机器学习来开发网络安全应用的公司</td><td>4 轮共 5360 万美元融资</td></tr><tr><td><a href="https://sparkcognition.com/" target="_blank" rel="noopener">SparkCognition</a></td><td>美国</td><td>机器学习、人工智能、数据分析</td><td>使用机器学习和人工智能技术来分析预测网络安全漏洞与系统故障</td><td>新一轮3250万美元融资</td></tr></tbody></table><h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><p>这是一份令人激动的名单，有的公司在做机器学习平台，有的是挑战前沿问题的研究。DeepMind 在被收购后依然在进行独立研究和运营。神秘的 Vicarious 还是持续研究「下一代人工智能算法」，日本创业公司 Preferred Networks 则利用深度学习让机械臂有了学习能力。</p><table><thead><tr><th>公司</th><th>国家</th><th>技术研究</th><th>产品应用</th><th>市值/估值/融资额</th></tr></thead><tbody><tr><td><a href="https://deepmind.com/" target="_blank" rel="noopener">DeepMind</a></td><td>英国</td><td>人工智能基础研究</td><td>AlphaGo、医疗健康、谷歌内部产品应用。</td><td>以4亿英镑（约5.32亿美元）被谷歌收购</td></tr><tr><td><a href="http://www.vicarious.com/" target="_blank" rel="noopener">Vicarious</a></td><td>美国</td><td>人工智能基础研究</td><td>新的计算机视觉系统，机器人视觉</td><td>五轮融资 7200 万美元</td></tr><tr><td><a href="https://bons.ai" target="_blank" rel="noopener">Bonsai</a></td><td>美国</td><td>深度学习</td><td>Inkling 脚本语言和集成开发环境Mastermind</td><td>760 万美元A轮融资</td></tr><tr><td><a href="https://www.preferred-networks.jp" target="_blank" rel="noopener">Preferred Networks</a></td><td>日本</td><td>深度学习</td><td>深度学习操作系统Chainer，机器学习在物联网的应用</td><td>三轮融资 1730 万美元</td></tr><tr><td><a href="https://skymind.ai/" target="_blank" rel="noopener">Skymind</a></td><td>美国</td><td>深度学习</td><td>深度学习企业应用包SKIL、开源框架Deeplearning4j</td><td>种子轮融资 300 万美元</td></tr><tr><td><a href="http://www.h2o.ai/" target="_blank" rel="noopener">H2O.ai</a></td><td>美国</td><td>机器学习</td><td>开源机器学习平台和商业化支持</td><td>四轮融资 3360 万美元</td></tr><tr><td><a href="https://uptake.com/" target="_blank" rel="noopener">Uptake</a></td><td>美国</td><td>数据挖掘、机器学习</td><td>为铁路、建筑等大行业提供数据预测分析SaaS服务</td><td>B轮融资5000万美元（2017 年 4 月）</td></tr><tr><td><a href="https://indico.io/" target="_blank" rel="noopener">Indico</a></td><td>美国</td><td>机器学习</td><td>为数据科学家提供图像、文本的识别和分析的工具</td><td>4轮融资共 438 万美元</td></tr><tr><td><a href="https://www.4paradigm.com/" target="_blank" rel="noopener">第四范式</a></td><td>中国</td><td>机器学习</td><td>金融应用和「先知」平台</td><td>A 轮融资数百万美元</td></tr><tr><td><a href="https://gamalon.com" target="_blank" rel="noopener">Gamalon</a></td><td>美国</td><td>机器学习</td><td>Bayesian Program Synthesis 可以自行编写代码，用最优的方法解释收集到的数据</td><td>来自DARPA的770万美元投资、来自Felicis Ventures 的 450 万美元种子轮融资</td></tr><tr><td><a href="https://www.datarobot.com/" target="_blank" rel="noopener">DataRobot</a></td><td>美国</td><td>机器学习</td><td>机器学习平台公司，DataRobot平台上有数百个开源机器学习算法</td><td>5400 万美元 C 轮融资</td></tr><tr><td><a href="http://www.petuum.com/" target="_blank" rel="noopener">Petuum</a></td><td>美国</td><td>机器学习与人工智能平台</td><td>PetuumOS、Poseidon 框架、Petuum Healthcare Solutions</td><td>9300万美元B轮融资</td></tr><tr><td><a href="https://algorithmia.com/" target="_blank" rel="noopener">Algorithmia</a></td><td>美国</td><td>算法</td><td>类似于苹果 App Store 的「算法应用」商店</td><td>1050 万美元 A 轮融资</td></tr></tbody></table><h1 id="大公司"><a href="#大公司" class="headerlink" title="大公司"></a>大公司</h1><p>科技巨头间的竞争异常激烈，从基础研究到开源平台，从计算资源再到产品升级。这关乎到下一代平台，开发者生态和用户。但与此同时，他们也承担着更大的责任，不久前，亚马逊、谷歌、 Facebook、IBM 和微软前所未有的走在一起，共同成立一家非营利组织，致力于推进公众对人工智能技术的理解，针对当前该领域的挑战和机遇执行可行方案。</p><table><thead><tr><th>公司</th><th>国家</th><th>技术研究</th><th>产品应用</th><th>市值/估值/融资额</th></tr></thead><tbody><tr><td><a href="https://www.google.com" target="_blank" rel="noopener">谷歌</a></td><td>美国</td><td>人工智能综合研究</td><td>TensorFlow等开源框架，Google Photos、Now、Inbox和搜索等多项产品和服务、硬件</td><td>市值 6701 亿美元</td></tr><tr><td><a href="https://www.facebook.com/" target="_blank" rel="noopener">Facebook</a></td><td>美国</td><td>人工智能综合研究</td><td>多个开源框架和硬件平台，Messenger、社交网络和定向广告等多项产品和服务</td><td>市值 4296 亿美元</td></tr><tr><td><a href="https://www.amazon.com/" target="_blank" rel="noopener">亚马逊</a></td><td>美国</td><td>人工智能综合研究</td><td>云服务、Echo等智能家居、机器人、电商产品应用</td><td>市值 4696 亿美元</td></tr><tr><td><a href="https://www.microsoft.com" target="_blank" rel="noopener">微软</a></td><td>美国</td><td>人工智能综合研究</td><td>CNTK等开源框架，Cortana、小冰等多项产业和服务，硬件</td><td>市值 5362 亿美元</td></tr><tr><td><a href="https://www.ibm.com/" target="_blank" rel="noopener">IBM</a></td><td>美国</td><td>人工智能综合研究</td><td>Watson、行业认知计算解决方案、量子计算机等</td><td>市值 1434 亿美元</td></tr><tr><td><a href="http://www.apple.com/" target="_blank" rel="noopener">苹果</a></td><td>美国</td><td>人工智能综合研究</td><td>基于智能手机等硬件的多项产品和硬件、智能助手、智能家居、医疗等</td><td>市值 8067 亿美元</td></tr><tr><td><a href="https://www.baidu.com/" target="_blank" rel="noopener">百度</a></td><td>中国</td><td>人工智能综合研究</td><td>开源框架PaddlePaddle、百度大脑、自动驾驶、互联网应用</td><td>市值 676 亿美元</td></tr><tr><td><a href="http://www.alibabagroup.com" target="_blank" rel="noopener">阿里巴巴</a></td><td>中国</td><td>人工智能综合研究</td><td>云服务、人工智能平台 DT PAI、电商产品应用</td><td>市值 3079 亿美元</td></tr><tr><td><a href="http://www.qq.com/" target="_blank" rel="noopener">腾讯</a></td><td>中国</td><td>人工智能综合研究</td><td>互联网应用</td><td>市值 25683.98亿人名币</td></tr><tr><td><a href="www.nvidia.com">英伟达</a></td><td>美国</td><td>人工智能硬件</td><td>GPU、深度学习超级计算机DGX-1、自动驾驶超级计算机Xavier</td><td>市值 832.07 亿美元</td></tr><tr><td><a href="http://www.intel.com" target="_blank" rel="noopener">英特尔</a></td><td>美国</td><td>人工智能硬件</td><td>CPU、Xeon Phi、Nervana</td><td>市值 1706.30 亿美元</td></tr><tr><td><a href="https://www.qualcomm.com" target="_blank" rel="noopener">高通</a></td><td>美国</td><td>人工智能硬件</td><td>移动智能设备芯片</td><td>市值约 899.36 亿美元</td></tr><tr><td><a href="https://www.xilinx.com" target="_blank" rel="noopener">赛灵思</a></td><td>美国</td><td>全可编程技术和器件</td><td>All Programmable FPGA、SoC和3D IC提供商</td><td>市值约 160.70 亿美元</td></tr><tr><td><a href="http://www.huawei.com/cn/" target="_blank" rel="noopener">华为</a></td><td>中国</td><td>人工智能综合研究、硬件</td><td>人机交互设备应用、芯片等</td><td>2017 年以 785.108 亿美元营业收入首次打入《财富》前百强</td></tr></tbody></table><h1 id="落榜名单"><a href="#落榜名单" class="headerlink" title="落榜名单"></a>落榜名单</h1><table><thead><tr><th>公司</th><th>国家</th><th>技术研究</th><th>产品应用</th><th>落榜理由</th></tr></thead><tbody><tr><td>Maluuba</td><td>加拿大</td><td>自然语言处理</td><td>自然语言理解的基础研究、智能设备的自然交互应用</td><td><a href="http://www.jiqizhixin.com/article/2144" target="_blank" rel="noopener">被微软收购</a></td></tr><tr><td>出门问问</td><td>中国</td><td>语音技术和自然语言处理</td><td>智能手表和车载智能语音应用</td><td></td></tr><tr><td>CureMetrix</td><td>美国</td><td>图像分析</td><td>基于影像分析的乳腺癌和肺癌检测</td><td></td></tr><tr><td>芋头科技</td><td>中国</td><td>语音识别、计算机视觉</td><td>Rokid、Pebble 智能机器人</td><td></td></tr><tr><td>Mobileye</td><td>以色列</td><td>计算机视觉、智能驾驶</td><td>汽车工业的计算机视觉算法和驾驶辅助系统的芯片技术的研究</td><td><a href="http://www.jiqizhixin.com/article/2467" target="_blank" rel="noopener">被英特尔收购</a></td></tr><tr><td>Kneron</td><td>美国</td><td>神经网络处理器 NPU 及解决方案</td><td>Kneron 可以提供终端的 NPU，并组建软件、硬件、云服务和端协同的整套 NPU 解决方案</td><td></td></tr><tr><td>KITT.AI</td><td>美国</td><td>自然语言处理</td><td>聊天机器人平台ChatFlow</td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;语音和自然语言&quot;&gt;&lt;a href=&quot;#语音和自然语言&quot; class=&quot;headerlink&quot; title=&quot;语音和自然语言&quot;&gt;&lt;/a&gt;语音和自然语言&lt;/h1&gt;&lt;p&gt;人工智能带来了精致可用的人机交互方式。和其他细分领域相比，语音和自然语言处理的融资额和估值在本榜单中均属最高。&lt;br&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://www.littlefeng.com/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>nginx是个啥?</title>
    <link href="https://www.littlefeng.com/2018/09/24/nginx-fo-qd/"/>
    <id>https://www.littlefeng.com/2018/09/24/nginx-fo-qd/</id>
    <published>2018-09-24T10:58:00.000Z</published>
    <updated>2018-09-24T15:53:46.014Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/assets/blogImg/nginx0.jpg" alt=""></p><p>Nginx，一名<strong>网红</strong>（网络服务器红人…）。</p><a id="more"></a><p>针对其找到仅有的一两本书籍，也直接深入到“源码剖析”的阶段。写得并不十分满意，况且我还不需要这些。<br>后来发现了原因，大概是因为<strong>“使用太简单了，都不值得出书”</strong>。<br>是的，Nginx把纷繁复杂的功能，浓缩成一份简单的配置，极易上手。<br>当它呈现到你面前时，感觉独具匠心。</p><h3 id="Nginx与NodeJs"><a href="#Nginx与NodeJs" class="headerlink" title="Nginx与NodeJs"></a>Nginx与NodeJs</h3><p>（这里的标题有点歧义。此处的NodeJs，皆引申为NodeJs所搭建的服务器。）</p><p>有人说，作为一名前端，<strong>我的真爱是NodeJs</strong>。<br>同时也认同，抛去性能之类的比较，单纯从实现的角度，NodeJs编写的服务器也能实现Nginx的各种功能。                </p><p>这些我都赞成，但使用Nginx并不意味着抛弃NodeJs。事实上，它们并不冲突，还可以在一起愉快的玩耍。              </p><p>在业内，这样的模型已很常见：资源转发，反向代理，静态资源处理，负载均衡，这些事情扔给Nginx来处理，只是几行配置的事情；同时在上游，让NodeJs去处理它最擅长的I/O等事情。               </p><p>合理分配各自<strong>擅长</strong>的事情，这样的思路，同样可以运用于前端开发中。                </p><p>以前用NodeJs几百行实现的服务器功能，在npm与github的海洋里花尽心思去寻找的模块，也许在Nginx里是一条成熟的配置。它能帮其分担很多事情，节约了成本。                  </p><h3 id="场景一：环境切换"><a href="#场景一：环境切换" class="headerlink" title="场景一：环境切换"></a>场景一：环境切换</h3><p>前端开发中，经常面临多个部署环境切换的问题。<br>我们通常用配hosts的方式去实现。更优化些，我们将机器的服务绑定了不同的域名：比如正式环境是a.qq.com，测试环境是test.a.qq.com。 </p><p>然而在拓展性和易用性方面，还不足够好。<br>而Nginx作为反向代理，就很容易处理资源转发的问题。                 </p><p>思路很简单：</p><blockquote><ol><li>读取请求里的cookie，如果键名host_id有值，则代理到这个IP地址；</li><li>如果没有，则代理到默认的正式环境（此处举例为1.1.1.1）;</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set $env_id &quot;1.1.1.1&quot;;</span><br><span class="line">if ( $http_cookie ~* &quot;host_id=(\S+)(;.*|$)&quot;) &#123;</span><br><span class="line">    set $env_id $1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">    proxy_set_header Host $host;</span><br><span class="line">    proxy_pass   http://$env_id:80;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那接下来的事情，就是<strong>怎样用最简便的方式，把IP种在cookie里？</strong><br>我们应用了nginx-http-footer-filter模块，html文件经过代理时，都注入了一小段js代码。</p><p>这段代码，会帮我们展示小菜单，点击某个环境时，则将IP种到cookie里，同时刷新页面，让Nginx完成环境切换。<br><img src="/assets/blogImg/nginx1.jpg" alt=""></p><p>切换环境，如今只需点击一次。</p><h3 id="场景二：SourceMap"><a href="#场景二：SourceMap" class="headerlink" title="场景二：SourceMap"></a>场景二：SourceMap</h3><p>在线上环境调试Js代码是件麻烦的事情，因为目前合格的前端部署，代码都应经过压缩。性能问题是优化了，debug可不怎么方便。</p><p>而SourceMap正好可以解决此问题。</p><p>在最新的各版本浏览器里，如果满足：</p><ol><li>压缩后的js文件后面有<code>//# sourceMappingURL=xxx.map</code>格式的注释</li><li>浏览器能正常访问到sourceMappingURL</li></ol><p>那么，就能把压缩过的代码还原。<br>要实现这样的功能，就必须：</p><ol><li>现网环境不带以上形式的注释，同时访问不到sourceMap（安全性考虑）</li><li>测试环境带注释，能访问sourceMap</li></ol><p>这样的模型，用<code>反向代理+内容纂改</code>的思路再合适不过。<br>每次构建编译时，我们会把sourceMap文件存放到一台机器（举例为1.1.1.1），命名为js文件名后加<code>.map</code>后缀。随后，使用Nginx，通过这几行配置就能把此功能实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.js$ &#123;</span><br><span class="line">    footer &quot;\n//# sourceMappingURL=$request_uri.map&quot;;</span><br><span class="line">    footer_types &quot;*&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要经过代理，在chrome里，我们能看到每份被压缩过的js文件，都有一个对应的源码文件。<br>你可以直接使用它来做打断点之类的操作，大大的提升了调试质量。<br><img src="/assets/blogImg/nginx2.jpg" alt=""></p><h3 id="场景三：内容纂改"><a href="#场景三：内容纂改" class="headerlink" title="场景三：内容纂改"></a>场景三：内容纂改</h3><p>其实在以上两个场景里，都涉及了“内容纂改”。<br>无论是说“纂改”还是“劫持”，大家的印象都不是什么好事情，但另一方面，他们又可以让事情有趣起来。</p><p>统一介绍下，Nginx涉及纂改的模块有：</p><ul><li><a href="https://m.oschina.net/blog/156826" target="_blank" rel="noopener">nginx_http_footer_filter</a>：往文件的底部添加文字，可包含Nginx的内置变量；</li><li><a href="http://nginx.org/en/docs/http/ngx_http_addition_module.html" target="_blank" rel="noopener">nginx_http_addition_module</a>：从一个url去读取内容，将之添加到文件的头部或顶部；</li><li><a href="http://nginx.org/en/docs/http/ngx_http_sub_module.html" target="_blank" rel="noopener">nginx_http_sub_module</a>：替换字符</li></ul><p>除去上面两种场景，合理运用这些模块对应的配置，可以做出许多小工具，这是很有想象力的事情。<br>单单针对移动web前端开发，就可以实现： </p><blockquote><ol><li>将<a href="http://people.apache.org/~pmuellr/weinre-docs/latest/" target="_blank" rel="noopener">weinre</a>脚本插入到html里，让移动web调试更加便捷。</li><li>移动web经常用到localStorage优化首屏，但debug时又会受到干扰，通过一个按钮很方便的清除本地缓存。</li><li>手机APP内嵌页面，很难将其网址分享给另一个人。通过一个按钮就能生成url对应的二维码等</li></ol></blockquote><h3 id="场景四：本地映射"><a href="#场景四：本地映射" class="headerlink" title="场景四：本地映射"></a>场景四：本地映射</h3><p>在Windows下的前端抓包调试，Fiddler+Willow的能力毋庸置疑。<br>而脱离了.NET体系的Linux和Mac，即使有一些代替工具，但某些方面还是略显不足。   </p><p>比如：<strong>线上接口映射到本地文件</strong>。<br>想到Fiddler的本质也是一个代理，而开启一个有这样能力的Nginx服务，并不是太难的事情。           </p><p>而且，我们可以做得更灵活，比如：</p><ul><li>同时支持慢速调试</li><li>同时支持目录层级映射</li><li>同时支持正则匹配</li><li>JSON返回的数据有可能是变化的（比如分页时候），同时支持动态数据</li></ul><p>这些场景，只运用到Nginx里的“<a href="http://www.linuxidc.com/Linux/2014-01/95493.htm" target="_blank" rel="noopener">rewrite规则</a>”。<br>从参考的文档可以大致看到，rewrite规则非常灵活，能完成各种场景的转发。 </p><p>最简单的模型中，我们把所有带<code>cgi-bin</code>路径的请求，rewite到本地的一个服务，同时带上请求的所有参数，<br>仅需这三行配置即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~ /cgi-bin/* &#123;</span><br><span class="line">    rewrite ^(.*)$ http://127.0.0.1:8080/cgi-bin/ last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>后续的事情，可以在本地创建一个cgi-bin文件夹，在里面放置需要映射的文本，并开启服务到8080端口即可。 </p><h3 id="场景五：移动侧调试"><a href="#场景五：移动侧调试" class="headerlink" title="场景五：移动侧调试"></a>场景五：移动侧调试</h3><p><code>Fiddler</code> 有一个勾选项 <code>Allow remote computers to connect</code>，并可以指定 <code>listen port</code> 可以使得手机/其它终端通过将本机设为代理而访问本机环境，与 <code>hosts</code> 配合会很实用。</p><p>这个功能，用Nginx也很容易做到。<br>通过 <code>default_server</code> 作为代理，手机终端通过设置网络代理为本机IP和相应的 <code>listen port</code>，从而可以访问本机的 Web 服务。</p><p>其中也是用到了<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html" target="_blank" rel="noopener">ngx_http_proxy_module</a>模块的配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> server &#123;</span><br><span class="line">    listen  80 default_server;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    resolver 8.8.8.8;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-Ip $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">        proxy_pass http://$host;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen  80;</span><br><span class="line">    server_name  ke.qq.com;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-Ip $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">        proxy_pass http://127.0.0.1:9091/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="边角料"><a href="#边角料" class="headerlink" title="边角料"></a>边角料</h3><p>除去特定场景，Nginx的一些配置也跟前端息息相关。以下简单罗列，作为边角材料。</p><p>1.<a href="https://github.com/alibaba/nginx-http-concat" target="_blank" rel="noopener">nginx_http_concat</a><br>资源合并，处理CDN combo。例如通过这样的方式<code>http://example.com/??style1.css,style2.css,foo/style3.css</code>访问合并后的资源。</p><p>2.<a href="http://nginx.org/en/docs/http/ngx_http_image_filter_module.html" target="_blank" rel="noopener">ngx_http_image_filter_module</a><br>图片处理。提供图片缩放，jpg压缩，旋转等特性。</p><p>3.适配PC与移动web<br>总体可运用<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html" target="_blank" rel="noopener">ngx_http_proxy_module</a>，去实现路径转发。判断平台类型的Nginx配置，在开源项目<a href="http://detectmobilebrowsers.com/" target="_blank" rel="noopener">detectmobilebrowsers</a>中可以找到。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>学习Nginx，只是出于开开眼界的目的。而的确发现了一些很有启发性的特质。<br>于前端开发，无论线上线下，熟练掌握基本配置，可以做出许多提高效率的工具。<br><strong>但既然是工具，熟手就好</strong>。 </p><p>比Fiddler更直观，但Nginx更底层，更灵活，应当按照实际选择即可。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/nginx0.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Nginx，一名&lt;strong&gt;网红&lt;/strong&gt;（网络服务器红人…）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://www.littlefeng.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="https://www.littlefeng.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Hello website!</title>
    <link href="https://www.littlefeng.com/2018/09/23/1st/"/>
    <id>https://www.littlefeng.com/2018/09/23/1st/</id>
    <published>2018-09-23T13:58:00.000Z</published>
    <updated>2018-09-24T15:54:24.119Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28191113&auto=0&height=66"></iframe><p>在微博大V的推荐和耗子叔的读书会的帮助下,个人博客网站终于建立起来了.</p><p>先看一下大体的预览图</p><p><img src="/assets/blogImg/pro.png" alt=""></p><a id="more"></a><h3 id="1-搭建个人博客网站的初衷"><a href="#1-搭建个人博客网站的初衷" class="headerlink" title="1 搭建个人博客网站的初衷"></a>1 搭建个人博客网站的初衷</h3><p>之前一直在csdn和博客园分享东西,但由于没有版权保护(百度的spider可以随便爬取),更可恨的是文章后期添油加醋太厉害了,完全违背作者的本意;</p><h3 id="2-博客的搭建过程"><a href="#2-博客的搭建过程" class="headerlink" title="2 博客的搭建过程"></a>2 博客的搭建过程</h3><p>按照B/S构建,后端搭建主要是服务器租用和域名注册解析,使之具有发布博客的能力,前端简单了,按照需要显示的模块直接定制功能.</p><h3 id="3-说明"><a href="#3-说明" class="headerlink" title="3 说明"></a>3 说明</h3><p>本人穷学生一枚,租用了腾讯云的服务器和域名解析,相对来讲比价便宜,腾讯云上也直接有限量的对象存储(COS),能用于直接存储图片啥的.</p><p><img src="/assets/blogImg/cloud.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=28191113&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;在微博大V的推荐和耗子叔的读书会的帮助下,个人博客网站终于建立起来了.&lt;/p&gt;
&lt;p&gt;先看一下大体的预览图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/blogImg/pro.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="主题" scheme="https://www.littlefeng.com/tags/%E4%B8%BB%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu下PPPOE拨号上网方法</title>
    <link href="https://www.littlefeng.com/2018/09/13/linux-pppoe/"/>
    <id>https://www.littlefeng.com/2018/09/13/linux-pppoe/</id>
    <published>2018-09-12T17:30:00.000Z</published>
    <updated>2018-09-24T15:42:10.737Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><center><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&id=27725294&auto=0&height=32"></iframe></center><h3 id="1-拨号上网"><a href="#1-拨号上网" class="headerlink" title="1.拨号上网"></a>1.拨号上网</h3><p>提到拨号上网,小伙伴们估计都熟悉的不得了,毕竟都是互联网刚诞生时候的作品.</p><p><img src="/assets/blogImg/IPV6.jpg" alt=""></p><center>IPv6 PPPoE接入 – 路由型RG：DHCPv6 PD</center><a id="more"></a><h3 id="2-Ubuntu下PPPOE拨号上网的步骤-命令行的方式"><a href="#2-Ubuntu下PPPOE拨号上网的步骤-命令行的方式" class="headerlink" title="2.Ubuntu下PPPOE拨号上网的步骤(命令行的方式)"></a>2.Ubuntu下PPPOE拨号上网的步骤(命令行的方式)</h3><h4 id="2-1-安装pppoecof"><a href="#2-1-安装pppoecof" class="headerlink" title="2.1.安装pppoecof"></a>2.1.安装pppoecof</h4><p>打开终端，输入命令 sudo apt-get install pppoeconf,提示输入密码,输入即可.</p><p><img src="/assets/blogImg/install.png" alt=""></p><h4 id="2-2-配置连接"><a href="#2-2-配置连接" class="headerlink" title="2.2.配置连接"></a>2.2.配置连接</h4><p>打开终端，输入命令pppoeconf,然后一路回车(enter),直到遇到如下界面:</p><p><img src="/assets/blogImg/username.png" alt=""></p><p>删除username,先输入运营商给的账号,然后在输入密码,继续一路回车,直到看到:</p><p><img src="/assets/blogImg/load.png" alt=""></p><p>即表示连接成功.</p><h4 id="2-3-断网命令"><a href="#2-3-断网命令" class="headerlink" title="2.3.断网命令"></a>2.3.断网命令</h4><p>打开终端，输入命令sudo poff.</p><h4 id="2-4-查看日志"><a href="#2-4-查看日志" class="headerlink" title="2.4.查看日志"></a>2.4.查看日志</h4><p>打开终端，输入命令plog.</p><p><img src="/assets/blogImg/log.png" alt=""></p><h4 id="2-5查看接口信息"><a href="#2-5查看接口信息" class="headerlink" title="2.5查看接口信息"></a>2.5查看接口信息</h4><p>打开终端，输入命令ifconfig ppp0.</p><h4 id="2-6-（可能的）频繁断网问题解决方法"><a href="#2-6-（可能的）频繁断网问题解决方法" class="headerlink" title="2.6.（可能的）频繁断网问题解决方法"></a>2.6.（可能的）频繁断网问题解决方法</h4><p>打开终端，输入命令sudo gedit /etc/ppp/peers/dsl-provider,将下图中的lcp-echo-failure改大一点,默认为4,即表示30秒内连接4次失败就断网,本文改成了40.</p><p><img src="/assets/blogImg/lcp.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;298&quot; height=&quot;52&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=27725294&amp;auto=0&amp;height=32&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;h3 id=&quot;1-拨号上网&quot;&gt;&lt;a href=&quot;#1-拨号上网&quot; class=&quot;headerlink&quot; title=&quot;1.拨号上网&quot;&gt;&lt;/a&gt;1.拨号上网&lt;/h3&gt;&lt;p&gt;提到拨号上网,小伙伴们估计都熟悉的不得了,毕竟都是互联网刚诞生时候的作品.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/blogImg/IPV6.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;center&gt;IPv6 PPPoE接入 – 路由型RG：DHCPv6 PD&lt;/center&gt;
    
    </summary>
    
    
      <category term="科学上网" scheme="https://www.littlefeng.com/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>20180910_ARTS_week02</title>
    <link href="https://www.littlefeng.com/2018/09/10/20180910-ARTS-week02/"/>
    <id>https://www.littlefeng.com/2018/09/10/20180910-ARTS-week02/</id>
    <published>2018-09-10T13:58:00.000Z</published>
    <updated>2018-09-24T15:41:30.088Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>ARTS是耗子哥的读书群的约定:</p><p>A:(Algorithm)每周至少做一个leetcode算法题</p><p>R:(Review)阅读并点评至少一篇英文技术文章</p><p>T:(Tip)学习至少一个技术技巧</p><p>S:(Share)分享一篇有观点和思考的技术文章</p><p>至少坚持一年~^o^~</p></blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1998319&auto=0&height=66"></iframe><h3 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h3><h3 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h3><h3 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h3><h3 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="ARTS" scheme="https://www.littlefeng.com/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础知识</title>
    <link href="https://www.littlefeng.com/2018/09/08/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://www.littlefeng.com/2018/09/08/Linux基础知识/</id>
    <published>2018-09-08T04:58:00.000Z</published>
    <updated>2018-09-24T15:42:37.746Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1、操作系统"><a href="#1、操作系统" class="headerlink" title="1、操作系统"></a>1、操作系统</h1><h2 id="1-1操作系统简介"><a href="#1-1操作系统简介" class="headerlink" title="1.1操作系统简介"></a>1.1操作系统简介</h2><a id="more"></a><p>操作系统作为接口（用户程序和硬件的接口）</p><p>用户</p><p>应用程序     </p><p>系统调用    终端命令    图像窗口</p><p>操作系统 windows</p><p>计算机硬件</p><p>cpu    内存     硬盘    声卡  等等</p><p>没有安装操作系统的计算机称为裸机</p><ul><li>如果想在裸机上编写程序，必须使用机器语言</li><li>如果在操作系统上安装了操作系统及支持的高级语言环境，就可以用高级语言开发</li></ul><h2 id="1-2不同领域的主流操作系统"><a href="#1-2不同领域的主流操作系统" class="headerlink" title="1.2不同领域的主流操作系统"></a>1.2不同领域的主流操作系统</h2><ul><li>桌面操作系统</li><li>服务器操作系统</li><li>嵌入式操作系统</li><li>移动设备操作系统</li></ul><h4 id="1-gt-桌面操作系统"><a href="#1-gt-桌面操作系统" class="headerlink" title="1&gt;桌面操作系统"></a>1&gt;桌面操作系统</h4><ul><li><p>Windows系列</p><p>用户群体大</p></li><li><p>masOS</p><p>适合开发人员</p></li><li><p>Linux</p><p>应用软件少</p></li></ul><h4 id="2-gt-服务器操作系统"><a href="#2-gt-服务器操作系统" class="headerlink" title="2&gt;服务器操作系统"></a>2&gt;服务器操作系统</h4><ul><li>Linux<ul><li>安全稳定免费</li><li>占有率高</li></ul></li><li>Windows Server<ul><li>付费</li><li>占用率低</li></ul></li></ul><h4 id="3-gt-嵌入式操作系统"><a href="#3-gt-嵌入式操作系统" class="headerlink" title="3&gt;嵌入式操作系统"></a>3&gt;嵌入式操作系统</h4><ul><li>Linux</li></ul><h4 id="4-gt-移动设备操作系统"><a href="#4-gt-移动设备操作系统" class="headerlink" title="4&gt;移动设备操作系统"></a>4&gt;移动设备操作系统</h4><ul><li>iOS</li><li>Android（基于Linux）</li></ul><h2 id="1-3-虚拟机"><a href="#1-3-虚拟机" class="headerlink" title="1.3 虚拟机"></a>1.3 虚拟机</h2><p>虚拟机（Virtual Machine）指通过软件模拟具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统</p><ul><li>虚拟机通过生成现有操作系统的全新虚拟镜像，具有真实操作系统完全一样的功能</li><li>进入虚拟机系统后，所有的操作都是在这个全新的系统里进行的，可以独立安装运行软件，保存数据，拥有自己的独立桌面，不会对真正的系统产生任何影响</li><li>而且能够实现现有系统与虚拟镜像之间的灵活切换的一类操作系统</li></ul><h2 id="1-4-操作系统发展史"><a href="#1-4-操作系统发展史" class="headerlink" title="1.4     操作系统发展史"></a>1.4     操作系统发展史</h2><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ul><li>了解操作系统发展史</li><li>知道Linux内核及发布版本的区别</li><li>知道Linux的应用领域</li></ul><p>1&gt;Unix</p><p>2&gt;Minix</p><p>3&gt;Linux</p><h4 id="Linux内核及发行版本"><a href="#Linux内核及发行版本" class="headerlink" title="Linux内核及发行版本"></a>Linux内核及发行版本</h4><ul><li>内核（kernel）是系统的心脏，是运行程序和管理磁盘等硬件的核心程序，提供了一个硬件和程序间的抽象层</li><li>Linux内核版本又分为稳定版和开发版</li><li>内核源码网址：<a href="http://www.kernel.org" target="_blank" rel="noopener">http://www.kernel.org</a></li></ul><h4 id="Linux发行版本"><a href="#Linux发行版本" class="headerlink" title="Linux发行版本"></a>Linux发行版本</h4><p>常见发行版本</p><ul><li>Ubuntu</li><li>Redhat</li><li>Fedora</li><li>openSUSE</li><li>Linux Mint</li><li>Debian</li><li>Manjaro</li><li>Mageia</li><li>CentOS</li><li>Arch</li></ul><h1 id="2、文件和目录（理解）"><a href="#2、文件和目录（理解）" class="headerlink" title="2、文件和目录（理解）"></a>2、文件和目录（理解）</h1><h2 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h2><ul><li>理解Linux文件目录结构</li></ul><h2 id="01-单用户操作系统和多用户操作系统"><a href="#01-单用户操作系统和多用户操作系统" class="headerlink" title="01.单用户操作系统和多用户操作系统"></a>01.单用户操作系统和多用户操作系统</h2><ul><li><strong>单用户操作系统</strong>：指一台计算机在同一时间内只能由一个用户使用，一个用户独自享用全部硬件和软件资源<ul><li>Windows XP之前的版本都是单用户操作系统</li></ul></li><li><strong>多用户操作系统</strong>：指一台计算机在同一时间内可以有多个用户使用，多个用户共同享用系统全部硬件和软件<ul><li><strong>Unix</strong>和<strong>Linux</strong>操作系统设计初衷就是多用户操作系统。</li></ul></li></ul><h2 id="02-Windows和Linux文件系统区别"><a href="#02-Windows和Linux文件系统区别" class="headerlink" title="02.Windows和Linux文件系统区别"></a>02.Windows和Linux文件系统区别</h2><h3 id="2-1Windows下的文件系统"><a href="#2-1Windows下的文件系统" class="headerlink" title="2.1Windows下的文件系统"></a>2.1Windows下的文件系统</h3><ul><li>在windows下，打开“计算机“，看到的是一个个驱动盘符</li><li>每个驱动都有自己的根目录结构，这样形成了多个树并列的情形</li></ul><h3 id="2-2Linux下的文件系统"><a href="#2-2Linux下的文件系统" class="headerlink" title="2.2Linux下的文件系统"></a>2.2Linux下的文件系统</h3><ul><li>在linux下，我们看到的不是盘符，是文件夹</li><li>Ubuntu没有盘符这个概念，只有一个根目录 <code>\</code>,所有文件都在它下面</li></ul><h3 id="2-3用户目录"><a href="#2-3用户目录" class="headerlink" title="2.3用户目录"></a>2.3用户目录</h3><p>位于<code>/home/user</code>,称为用户工作目录或者家目录，表示方式</p><p><code>/home/user    ~</code></p><h3 id="2-4Linux主要目录速查表"><a href="#2-4Linux主要目录速查表" class="headerlink" title="2.4Linux主要目录速查表"></a>2.4Linux主要目录速查表</h3><ul><li>/：根目录，一般根目录下只放目录，在Linux下只有一个根目录</li><li>/home:系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下<ul><li><code>~</code>表示当前用户的家目录</li><li><code>~edu</code>表示用户<code>edu</code>的家目录</li></ul></li><li>/bin、/usr/bin：可执行二进制文件目录，如常用命令ls、tar、没、cat等</li><li>/boot：放置Linux启动时的一些文件，如Linux内核文件：<code>/boot/vmlinuz</code>，系统引导管理器：<code>/boot/grub</code></li><li><p>/etc：系统配置文件存放目录，不建议在此文件下存放可执行文件，重要的配置文件有</p><ul><li>/etc/inittab</li><li>/etc/fstb</li><li>/etc/init.d</li><li>/etc/x11</li><li>/etc/sysconfig</li><li>/etc/xinetd.d</li></ul></li><li><p>/opt：给主机额外安装软件所摆放的目录</p></li><li>/lost+fount：系统异常产生错误时，会将一些遗失的片段存放在此目录</li><li>/mnt：/media：光盘默认挂载点，通常光盘挂载于/mnt/cdrom下，也不一定，可以选择任意位置进行挂载</li><li>/proc：此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放在内存中，所以不占用磁盘空间，比较重要的文件</li><li>/root：系统管理root家目录</li></ul><h1 id="3、Ubuntu图形界面入门"><a href="#3、Ubuntu图形界面入门" class="headerlink" title="3、Ubuntu图形界面入门"></a>3、Ubuntu图形界面入门</h1><h2 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h2><p>熟悉Ubuntu图形界面</p><h2 id="01-Ubuntu任务栏"><a href="#01-Ubuntu任务栏" class="headerlink" title="01.Ubuntu任务栏"></a>01.Ubuntu任务栏</h2><ul><li>任务之间可以互相切换</li><li>添加和取消应用在任务栏</li></ul><h2 id="02-窗口操作按钮"><a href="#02-窗口操作按钮" class="headerlink" title="02.窗口操作按钮"></a>02.窗口操作按钮</h2><ul><li>最大化</li><li>最小化</li><li>关闭</li></ul><h2 id="03-菜单条"><a href="#03-菜单条" class="headerlink" title="03.菜单条"></a>03.菜单条</h2><ul><li>在界面最上方，移动鼠标显示</li></ul><h1 id="4、常用Linux基本命令使用"><a href="#4、常用Linux基本命令使用" class="headerlink" title="4、常用Linux基本命令使用"></a>4、常用Linux基本命令使用</h1><h2 id="目标-3"><a href="#目标-3" class="headerlink" title="目标"></a>目标</h2><ul><li>理解学习Linux终端命令的原因</li><li>常用Linux命令体验</li></ul><h2 id="01学习Linux终端命令的原因"><a href="#01学习Linux终端命令的原因" class="headerlink" title="01学习Linux终端命令的原因"></a>01学习Linux终端命令的原因</h2><ul><li><p>LInux刚出世时并没有图形界面，所有的操作全靠命令完成，如磁盘操作，文件存取，目录操作，进程管理，文件权限设定等</p></li><li><p>在工作中，大量的服务器维护工作都是在远程通过SSH客户端来完成的，并没有图形界面，所有的维护工作都需要通过命令来完成</p></li><li><p>在工作中，身为后端程序员，必须或多或少的掌握一些终端命令</p></li><li><p>Linux发行版的终端命令有200多个，但是常用的终端命令只要10多个</p></li><li><p>学习终端命令的技巧</p><p>不要死记硬背，对于常用命令，多用就行</p><p>可以尝试一次学会所有的命令，有些命令不常用，遇到的时候查资料就可以了</p></li></ul><h2 id="02常用Linux基本终端命令"><a href="#02常用Linux基本终端命令" class="headerlink" title="02常用Linux基本终端命令"></a>02常用Linux基本终端命令</h2><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td style="text-align:left">01</td><td style="text-align:left">ls</td><td>list</td><td>查看当前文件夹下的内容</td></tr><tr><td style="text-align:left">02</td><td style="text-align:left">pwd</td><td>print wrok directory</td><td>查看当前所在文件夹</td></tr><tr><td style="text-align:left">03</td><td style="text-align:left">cd[目录名]</td><td>change directory</td><td>切换文件夹</td></tr><tr><td style="text-align:left">04</td><td style="text-align:left">touch[文件夹]</td><td>touch</td><td>如果文件夹不存在，新建文件夹</td></tr><tr><td style="text-align:left">05</td><td style="text-align:left">mkdir[目录名]</td><td>make directory</td><td>创建目录</td></tr><tr><td style="text-align:left">06</td><td style="text-align:left">rm[文件名]</td><td>remove</td><td>删除制定的文件名</td></tr><tr><td style="text-align:left">07</td><td style="text-align:left">clear</td><td>clear</td><td>清屏</td></tr></tbody></table><blockquote><p>小技巧</p><ul><li><code>ctrl + shift + =</code>放大终端窗口的字体显示</li><li><code>ctrl + -</code>缩小终端窗口的字体显示</li></ul></blockquote><h2 id="03自动补全"><a href="#03自动补全" class="headerlink" title="03自动补全"></a>03自动补全</h2><ul><li><p>敲出<code>文件</code>/<code>目录</code>/<code>命令</code>的前几个字母后，按下<code>tab</code>键</p><p>如果输入没有歧义，则系统自动补全</p></li></ul><h1 id="5、Linux终端命令格式"><a href="#5、Linux终端命令格式" class="headerlink" title="5、Linux终端命令格式"></a>5、Linux终端命令格式</h1><h2 id="目标-4"><a href="#目标-4" class="headerlink" title="目标"></a>目标</h2><ul><li>了解终端命令格式</li><li>知道如何查阅终端命令帮助信息</li></ul><h2 id="01终端命令格式"><a href="#01终端命令格式" class="headerlink" title="01终端命令格式"></a>01终端命令格式</h2><p><code>commod [-options] [parament]</code></p><p>说明：</p><ul><li><code>commod</code>：命令名，相应功能的英文单词，或者英文单词的缩写</li><li><code>-options</code>：选项，可以对命令进行控制，也可以省略</li><li><code>parament</code>：传给命令的参数，可以是零个，一个或者多个</li><li><code>[]</code>：代表可选</li></ul><h2 id="02查询终端命令帮助信息（知道）"><a href="#02查询终端命令帮助信息（知道）" class="headerlink" title="02查询终端命令帮助信息（知道）"></a>02查询终端命令帮助信息（知道）</h2><blockquote><p>提示</p><ul><li>现阶段只需要知道通过以下两种方式可以查询命令的帮助信息</li><li>先学习常用命令以及常用选项的使用即可，工作中遇见可以使用网络搜索</li></ul></blockquote><h3 id="2-1-–help"><a href="#2-1-–help" class="headerlink" title="2.1 –help"></a>2.1 –help</h3><p><code>command --help</code></p><p>说明：显示<code>command</code>命令的帮助信息</p><h3 id="2-2-man"><a href="#2-2-man" class="headerlink" title="2.2 man"></a>2.2 man</h3><p><code>man command</code></p><p>说明：<code>command</code>命令的使用手册</p><blockquote><p><code>man</code>是manual的缩写，是Linux提供的一个手册，包含了大部分命令、函数的详细使用说明</p></blockquote><p>使用 <code>man</code>时的操作键：</p><table><thead><tr><th>操作键</th><th>功能</th></tr></thead><tbody><tr><td>空格键</td><td>显示手册下一页</td></tr><tr><td>Enter键</td><td>一次滚动手册的一行</td></tr><tr><td>b</td><td>回滚一屏</td></tr><tr><td>f</td><td>前滚一屏</td></tr><tr><td>q</td><td>退出</td></tr><tr><td>/word</td><td>搜索word字符串</td></tr></tbody></table><h1 id="6、文件目录常用命令"><a href="#6、文件目录常用命令" class="headerlink" title="6、文件目录常用命令"></a>6、文件目录常用命令</h1><h2 id="目标-5"><a href="#目标-5" class="headerlink" title="目标"></a>目标</h2><ul><li><strong>查看目录内容</strong><ul><li><code>ls</code>    </li></ul></li><li><strong>切换目录</strong><ul><li><code>cd</code></li></ul></li><li><strong>创建和删除操作</strong><ul><li><code>touch</code></li><li><code>rm</code></li><li><code>mkdir</code></li></ul></li><li><strong>移动和拷贝文件</strong><ul><li><code>cp</code></li><li><code>mv</code></li></ul></li><li><strong>查看文件内容</strong><ul><li><code>cat</code></li><li><code>more</code></li><li><code>grep</code></li></ul></li><li>其他<ul><li><code>echo</code></li><li>重定向<code>&gt;</code>和<code>&gt;&gt;</code></li><li>管道<code>|</code></li></ul></li></ul><h2 id="01-查看文件目录"><a href="#01-查看文件目录" class="headerlink" title="01.查看文件目录"></a>01.查看文件目录</h2><h3 id="1-1终端实用技巧"><a href="#1-1终端实用技巧" class="headerlink" title="1.1终端实用技巧"></a>1.1终端实用技巧</h3><h4 id="1-gt-自动补全"><a href="#1-gt-自动补全" class="headerlink" title="1&gt;自动补全"></a>1&gt;自动补全</h4><ul><li>敲出<code>文件</code>/<code>目录</code>/<code>命令</code>的前几个字母后，按下<code>tab</code>键<ul><li>如果输入没有歧义，则系统自动补全</li><li>如果还存在其他<code>文件</code>/<code>目录</code>/<code>命令</code>，在按一下<code>tab</code>键，系统会提示可能存在的命令</li></ul></li></ul><h4 id="2-gt-曾经使用过的命令"><a href="#2-gt-曾经使用过的命令" class="headerlink" title="2&gt;曾经使用过的命令"></a>2&gt;曾经使用过的命令</h4><ul><li>按<code>上</code>/<code>下</code>光标键，可以在曾经使用的命令之间切换</li><li>如果想要退出选择，并且不想执行当前选中的命令，可以按<code>ctrl+c</code></li></ul><h3 id="1-2-ls命令说明"><a href="#1-2-ls命令说明" class="headerlink" title="1.2 ls命令说明"></a>1.2 ls命令说明</h3><ul><li><code>ls</code>是中文单词list的简写，其功能是列出目录的功能，是用户最常用的命令之一，类似于DOS下的<code>dir</code>命令</li></ul><p><strong>Linux下文件和目录的特点</strong></p><ul><li>Linux文件或者目录名称最长可以有<code>256</code>个字符</li><li>以<code>.</code>开头的位隐藏文件，需要用-a参数才能显示</li><li><code>.</code>代表当前目录</li><li><code>..</code>代表上一级目录</li></ul><h3 id="1-3-ls常用选项"><a href="#1-3-ls常用选项" class="headerlink" title="1.3 ls常用选项"></a>1.3 ls常用选项</h3><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-a</td><td>显示指定目录下所有子目录与文件，包括隐藏文件</td></tr><tr><td>-l</td><td>以列表的方式显示文件的详细信息</td></tr><tr><td>-h</td><td>配合<code>-l</code>以人性化的方式显示详细信息</td></tr></tbody></table><p><strong>计算机中文件大小的表示方式（科普）</strong></p><table><thead><tr><th>单位</th><th>英文</th><th>含义</th></tr></thead><tbody><tr><td>字节</td><td>B（Byte）</td><td>在计算机中作为一个数字单元，一般为8位二进制数</td></tr><tr><td>千</td><td>K（kibibyte）</td><td>1KB=1024B，千字节（1024**10）</td></tr><tr><td>兆</td><td>M（Mebibyte）</td><td>1MB=1024KB，百万字节</td></tr><tr><td>千兆</td><td>G（Gigabyte）</td><td>1GB=1024MB，十亿字节，千兆字节</td></tr><tr><td>太</td><td>T（Terabyte）</td><td>1TB=1024GB，万亿字节，太字节</td></tr><tr><td>拍</td><td>P（Petabyte）</td><td>1PB=1024TB，千万亿字节，拍字节</td></tr><tr><td>艾</td><td>E（Exabyte）</td><td>1EB=1024PB，百亿亿字节，艾字节</td></tr><tr><td>泽</td><td>Z（Zettabyte）</td><td>1ZB=1024EB，十万亿亿字节，泽字节</td></tr><tr><td>尧</td><td>Y（Yottabyte）</td><td>1YB=1024ZB，百万字节,尧字节</td></tr></tbody></table><h3 id="1-4-ls通用符的设置"><a href="#1-4-ls通用符的设置" class="headerlink" title="1.4 ls通用符的设置"></a>1.4 ls通用符的设置</h3><table><thead><tr><th>通配符</th><th>含义</th></tr></thead><tbody><tr><td><code>.</code></td><td>代表任意个数的字符</td></tr><tr><td><code>?</code></td><td>代表任意一个字符，至少一个</td></tr><tr><td><code>[]</code></td><td>表示可以匹配字符组中的任意一个</td></tr><tr><td><code>[abc]</code></td><td>匹配a，b，c中的任意一个</td></tr><tr><td><code>[a-f]</code></td><td>匹配a到f范围内的任意一个</td></tr></tbody></table><h2 id="02-切换目录"><a href="#02-切换目录" class="headerlink" title="02.切换目录"></a>02.切换目录</h2><h3 id="2-1-cd"><a href="#2-1-cd" class="headerlink" title="2.1 cd"></a>2.1 cd</h3><ul><li><code>cd</code>是英文单词<strong>change directora</strong>的简写，其功能是更改当前的工作目录，也是用户最常用的命令之一</li></ul><blockquote><p><em>注意：Linux所有的<strong>目录</strong>和<strong>文件名</strong>是区分大小写的</em></p></blockquote><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>cd</td><td>切换到当前用户的主目录（/home/用户目录）</td></tr><tr><td>cd ~</td><td>切换到当前用户的主目录（/home/用户目录）</td></tr><tr><td>cd .</td><td>保持当前目录不变</td></tr><tr><td>cd ..</td><td>切换到上级目录</td></tr><tr><td>cd -</td><td>可以在最近的两次工作目录之间来回切换</td></tr></tbody></table><h3 id="2-2-相对路径和绝对路径"><a href="#2-2-相对路径和绝对路径" class="headerlink" title="2.2 相对路径和绝对路径"></a>2.2 相对路径和绝对路径</h3><ul><li><strong>绝对命令</strong>：在输入路径时，最前面不是/或者~，表示相对于<strong>当前目录</strong>所在的目录位置</li><li><strong>相对命令</strong>：在输入路径时，最前面是/或者~，表示从<strong>根目录/家目录</strong>开始的具体位置</li></ul><h2 id="03-创建和删除命令"><a href="#03-创建和删除命令" class="headerlink" title="03.创建和删除命令"></a>03.创建和删除命令</h2><h3 id="3-1-touch"><a href="#3-1-touch" class="headerlink" title="3.1 touch"></a>3.1 touch</h3><ul><li>创建文件或者修改文件时间<ul><li>如果文件不存在，可以创建一个空白文件</li><li>如果文件存在，可以修改文件的最后修改时间</li></ul></li></ul><h3 id="3-2-mkdir"><a href="#3-2-mkdir" class="headerlink" title="3.2 mkdir"></a>3.2 mkdir</h3><ul><li>创建一个新的目录</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-p</td><td>可以递归创建文件</td></tr></tbody></table><blockquote><p><strong>新建目录的名称</strong>不能与当前目录中<strong>已有的目录或者文件名</strong>相同</p></blockquote><h3 id="3-3-rm"><a href="#3-3-rm" class="headerlink" title="3.3 rm"></a>3.3 rm</h3><ul><li>删除文件或者目录</li></ul><blockquote><p>使用<code>rm</code>命令要小心，因为文件删除后不能恢复</p></blockquote><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-f</td><td>强制删除，忽略不存在的文件，无需提示</td></tr><tr><td>-r</td><td>递归删除目录下的内容，删除文件夹时必须添加次参数</td></tr></tbody></table><h2 id="04-拷贝和移动文件"><a href="#04-拷贝和移动文件" class="headerlink" title="04.拷贝和移动文件"></a>04.拷贝和移动文件</h2><table><thead><tr><th>序号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>tree [目录名]</td><td>tree</td><td>以树状图列出文件目录结构</td></tr><tr><td>02</td><td>cp 源文件 目标文件</td><td>copy</td><td>复制文件或目录</td></tr><tr><td>03</td><td>mv 源文件 目标文件</td><td>move</td><td>移动文件或者目录/文件或者目录重命名</td></tr></tbody></table><h3 id="4-1-tree"><a href="#4-1-tree" class="headerlink" title="4.1 tree"></a>4.1 tree</h3><ul><li><code>tree</code>命令可以以树状图列出文件目录</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-d</td><td>只显示目录</td></tr></tbody></table><h3 id="4-2-cp"><a href="#4-2-cp" class="headerlink" title="4.2 cp"></a>4.2 cp</h3><ul><li><code>cp</code>的功能是将给出的<strong>文件或者目录</strong>复制到另一个文件夹目录当中，相当于DOS下的copy命令</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-i</td><td>覆盖文件前提示</td></tr><tr><td>-r</td><td>若给出的源文件是目录文件，则cp将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名</td></tr></tbody></table><h3 id="4-3-mv"><a href="#4-3-mv" class="headerlink" title="4.3 mv"></a>4.3 mv</h3><ul><li><code>mv</code>命令可以用来<strong>移动文件或者目录</strong>，也可以用作给<strong>文件或目录重命名</strong></li></ul><table><thead><tr><th style="text-align:left">选项</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:left">-i</td><td>覆盖文件前提示</td></tr></tbody></table><h2 id="05-查看文件内容"><a href="#05-查看文件内容" class="headerlink" title="05.查看文件内容"></a>05.查看文件内容</h2><table><thead><tr><th>序号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>cat 文件名</td><td>concatenate</td><td>查看文件内容如、创建文件、合并文件、追加文件内容等功能</td></tr><tr><td>02</td><td>more 文件名</td><td>more</td><td>分屏显示文件内容</td></tr><tr><td>03</td><td>grep 搜索文件名称</td><td>grep</td><td>搜索文件内容</td></tr></tbody></table><h3 id="5-1-cat"><a href="#5-1-cat" class="headerlink" title="5.1 cat"></a>5.1 cat</h3><ul><li><code>cat</code>命令可以用来<strong>查看文件内容、创建文件、合并文件、追加文件内容</strong>等功能</li><li><code>cat</code>会一次显示所有的内容，适合<strong>文件内容较少</strong>的文件</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-b</td><td>对非空输出行编号</td></tr><tr><td>-n</td><td>对输出所有行编号</td></tr></tbody></table><blockquote><p><em>Linux中还有一个 <code>nl</code>的命令和 <code>cat -b</code>的命令等价</em></p></blockquote><h3 id="5-2-more"><a href="#5-2-more" class="headerlink" title="5.2 more"></a>5.2 more</h3><ul><li><code>more</code>命令可以用于分屏展示文件内容，每次只显示一页内容</li><li>适合于查看内容较多的文件</li></ul><p>使用<code>more</code>的操作键</p><table><thead><tr><th>操作键</th><th>功能</th></tr></thead><tbody><tr><td>空格键</td><td>显示手册下一页</td></tr><tr><td>Enter键</td><td>一次滚动手册的一行</td></tr><tr><td>b</td><td>回滚一屏</td></tr><tr><td>f</td><td>前滚一屏</td></tr><tr><td>q</td><td>退出</td></tr><tr><td>/word</td><td>搜索word字符串 5.3</td></tr></tbody></table><h3 id="5-3-grep"><a href="#5-3-grep" class="headerlink" title="5.3 grep"></a>5.3 grep</h3><ul><li>LInux中<code>grep</code>命令是一种强大的文本搜索工具</li><li><code>grep</code>允许对文本进行模式查找，所谓模式查找，又称为正则表达式</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-n</td><td>显示查找结果的匹配行及行号</td></tr><tr><td>-v</td><td>显示不包含匹配文本的所有行（相当于求凡）</td></tr><tr><td>-i</td><td>忽略大小写</td></tr></tbody></table><ul><li>常用的模式查找</li></ul><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>^a</td><td>行首，搜索以a开始的所有行</td></tr><tr><td>a$</td><td>行尾，搜索以a结尾的所有行</td></tr></tbody></table><h2 id="06-其他"><a href="#06-其他" class="headerlink" title="06.其他"></a>06.其他</h2><h3 id="6-1-echo-文字内容"><a href="#6-1-echo-文字内容" class="headerlink" title="6.1 echo 文字内容"></a>6.1 echo 文字内容</h3><ul><li><code>echo</code>会在终端中显示参数指定的文字，通常会和重定向联合使用</li></ul><h3 id="6-2-重定向-gt-和-gt-gt"><a href="#6-2-重定向-gt-和-gt-gt" class="headerlink" title="6.2 重定向&gt;和&gt;&gt;"></a>6.2 重定向&gt;和&gt;&gt;</h3><ul><li>Linux允许将命令执行结果重定向到一个文件</li><li><p>将本应显示在终端上的内容 <strong>输出/追加</strong>到指定文件中</p><p>其中</p></li><li><p><code>&gt;</code>表示输出，会覆盖文件原有内容</p></li><li><code>&gt;&gt;</code>表示追加，会将内容追加到已有文件末尾</li></ul><h3 id="6-3-管道"><a href="#6-3-管道" class="headerlink" title="6.3 管道|"></a>6.3 管道|</h3><ul><li>Linux允许将一个命令的输出，可以通过<strong>管道</strong>作为另一个命令的输入</li><li>可以理解现实生活中的管子，管子一头塞进去一个东西，从另一头取出来，这里<code>|</code>的左右分为两端，左端塞东西（写），右边取东西（读）</li></ul><p>常用的管道命令有</p><ul><li><code>more</code>分屏显示内容</li><li><code>grep</code>在执行命令的基础上，查询指定的文件</li></ul><h1 id="7、远程管理常用命令"><a href="#7、远程管理常用命令" class="headerlink" title="7、远程管理常用命令"></a>7、远程管理常用命令</h1><h2 id="目标-6"><a href="#目标-6" class="headerlink" title="目标"></a>目标</h2><ul><li>关机/重启<ul><li><code>shut down</code></li></ul></li><li>查看或配置网卡信息<ul><li><code>ifconfig</code></li><li><code>ping</code></li></ul></li><li>远程登录和复制文件<ul><li><code>ssh</code></li><li><code>scp</code></li></ul></li></ul><h2 id="01-关机-重启"><a href="#01-关机-重启" class="headerlink" title="01.关机/重启"></a>01.关机/重启</h2><table><thead><tr><th>序号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>shut down 选项 时间</td><td>shutdown</td><td>关机/重启启动</td></tr></tbody></table><h3 id="1-1-shut-down"><a href="#1-1-shut-down" class="headerlink" title="1.1 shut down"></a>1.1 shut down</h3><ul><li><code>shut down</code>可以安全关闭或者重新启动系统</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-r</td><td>重新启动</td></tr></tbody></table><blockquote><p>提示：</p><ul><li>不指定选项和参数，默认表示一分钟之后关闭系统</li><li>远程维护服务器时，最好不要关闭系统，而应该重新启动系统</li></ul></blockquote><ul><li>常用命令示例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 重新启动操作系统，其中now表示现在</span><br><span class="line">$ shut down -r now</span><br><span class="line"></span><br><span class="line"># 立刻关机，其中now表示现在</span><br><span class="line">$ shut down now</span><br><span class="line"></span><br><span class="line"># 系统在今天的20:25关机</span><br><span class="line">$ shut down 20:25</span><br><span class="line"></span><br><span class="line"># 系统在过10分钟关机</span><br><span class="line">$ shut down +10</span><br><span class="line"></span><br><span class="line"># 取消之前的关机计划</span><br><span class="line">$ shut down -c</span><br></pre></td></tr></table></figure><h2 id="02-查看或者配置网卡信息"><a href="#02-查看或者配置网卡信息" class="headerlink" title="02.查看或者配置网卡信息"></a>02.查看或者配置网卡信息</h2><table><thead><tr><th>序号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>ifconfig</td><td>configure a network interface</td><td>查看/配置当前计算机的网卡配置信息</td></tr><tr><td>02</td><td>ping ip地址</td><td>ping</td><td>检测目标ip地址的链接是否正常</td></tr></tbody></table><h3 id="2-1-网卡和ip地址"><a href="#2-1-网卡和ip地址" class="headerlink" title="2.1 网卡和ip地址"></a>2.1 网卡和ip地址</h3><p>网卡</p><ul><li>网卡是一个专门负责网络通讯的硬件设备</li><li><strong>IP地址</strong>是设置在网卡上的地址信息</li></ul><blockquote><p><em>我们可以把电脑比作电话，网卡相当于SIM卡，IP地址相当于电话号码</em></p></blockquote><p>IP地址</p><ul><li>每台联网的电脑上面都有IP地址，是保证电脑之间正常通讯的的重要设置</li></ul><blockquote><p><em>注意：每台电脑的IP地址不能相同，否则会出现IP地址冲突，并且没有办法正常通讯</em></p></blockquote><h3 id="2-2-ifconfig"><a href="#2-2-ifconfig" class="headerlink" title="2.2 ifconfig"></a>2.2 ifconfig</h3><ul><li><code>ifconfig</code>可以查看/配置计算机当前的网卡驱动</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查看网卡配置 信息</span><br><span class="line">$ ifconfig</span><br><span class="line"></span><br><span class="line"># 查看网卡对应的 IP 地址</span><br><span class="line">$ ifconfig | grep inet</span><br></pre></td></tr></table></figure><blockquote><p>提示：一台计算机中可能会有一个物理网卡，多个虚拟网卡，在Linux中物理网卡通常以<code>ensXX</code>表示</p></blockquote><ul><li><code>127.0.0.1</code>称为本地回环/回环地址，一般用于测试本机网卡是否正常</li></ul><h3 id="2-3-ping"><a href="#2-3-ping" class="headerlink" title="2.3 ping"></a>2.3 ping</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 检测目标主机是否正确连接</span><br><span class="line">$ ping 目标主机IP地址</span><br><span class="line"></span><br><span class="line"># 检测本地网卡工作正常</span><br><span class="line">$ ping 127.0.0.1</span><br></pre></td></tr></table></figure><ul><li><code>ping</code>一般由于检测当前计算机与目标计算机之间的网络连接是否通畅，时间数值越大，连接速度越慢</li></ul><blockquote><ul><li><code>ping</code>的工作原理与潜水艇的声呐相似，<code>ping</code>这个命令就是取自声呐的声音</li><li>网络管理员之间，也经常将<code>ping</code>用作动词，——ping一下计算机X，看它是否开着</li></ul></blockquote><p>原理：网络上的机器都有唯一的IP地址，通过向这个IP地址发送一个数据包，对方收到后，返回一个数据包，通过接受数据包的时间，来判断目标主机的存在状况。</p><blockquote><p>提示：在Linux中，终止终端程序的运行，一般使用<code>ctrl+c</code></p></blockquote><h2 id="03-远程登录和复制文件"><a href="#03-远程登录和复制文件" class="headerlink" title="03.远程登录和复制文件"></a>03.远程登录和复制文件</h2><table><thead><tr><th>序号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>ssh 用户名@ip</td><td>secure shell</td><td>关机/重新启动</td></tr><tr><td>02</td><td>scp 用户名@ip:文件名或路径  用户名@ip:文件名或路径</td><td>secure copy</td><td>远程复制文件</td></tr></tbody></table><h3 id="3-1-ssh基础（重点）"><a href="#3-1-ssh基础（重点）" class="headerlink" title="3.1 ssh基础（重点）"></a>3.1 ssh基础（重点）</h3><p>在Linux中SSH是非常重要的工具，通过<strong>SSH客户端</strong>可以连接到运行了<strong>SSH服务器</strong>的远程机器上</p><ul><li>SSH客户端是一种使用<code>secure shell (SSH)</code>协议连接到远程计算机的计算机软件</li><li><code>SSH</code>目前教可靠，专为远程登录会话和其他网络服务器提供安全性的协议<ul><li>利用<code>SSH协议</code>可以有效防止远程管理过程中的消息泄露</li><li>通过<code>SSH协议</code>可以对所有传输数据进行加密，也能够防止 <strong>DNS 欺骗</strong> 和 <strong>IP 欺骗</strong></li></ul></li><li><code>SSH</code>的另一项优点是传输的数据可以是经过压缩的，所以可以加快传输的速度</li></ul><h4 id="1）域名-和-端口号"><a href="#1）域名-和-端口号" class="headerlink" title="1）域名 和 端口号"></a>1）域名 和 端口号</h4><p><strong>域名</strong></p><ul><li>域名是一串由点分隔的组成，如：<code>www.baidu.com</code></li><li>是IP地址的别名，方便用户记忆</li></ul><p><strong>端口号</strong></p><ul><li><strong>IP地址</strong>：通过<strong>IP地址</strong>以找到网络上的<strong>计算机</strong></li><li><p><strong>端口号</strong>：通过<strong>端口号</strong>可以找到<strong>计算机上的运行程序</strong></p><ul><li><strong>SSH</strong>服务器的默认端口号是<code>22</code>，如果是默认端口号，在连接的时候可以省略</li></ul></li><li><p>常见的服务器端口号列表</p></li></ul><table><thead><tr><th>序号</th><th>服务</th><th>端口号</th></tr></thead><tbody><tr><td>01</td><td>SSH服务</td><td>22</td></tr><tr><td>02</td><td>Web服务</td><td>80</td></tr><tr><td>03</td><td>HTTPS</td><td>443</td></tr><tr><td>04</td><td>FTP服务器</td><td>21</td></tr></tbody></table><p><code>IP:80</code></p><h4 id="2）SSH-客户端的简单实用"><a href="#2）SSH-客户端的简单实用" class="headerlink" title="2）SSH 客户端的简单实用"></a>2）SSH 客户端的简单实用</h4><p><code>ssh [-p port] user@remote</code></p><ul><li><code>user</code>是远程机器上的用户名，如果不指定的话默认为当前用户名</li><li><code>remote</code>是远程机器的地址，可以是<strong>IP/域名</strong>，或者是后面提到的别名</li><li><code>port</code>是 SSH Server 监听的端口，如果不指定，就默认为22</li></ul><blockquote><p>提示：</p><ul><li>使用<code>exit</code>退出当前用户的登录</li></ul><p>注意：</p><ul><li><code>ssh</code>这个终端命令只能在<code>Linux</code>或者<code>UNIX</code>系统下使用</li><li>如果是在<code>Windows</code>系统中，可以安装<code>PuTTY</code>或者<code>XSHeLL</code>客户端软件即可</li></ul><p>提示：</p><ul><li>在工作中，SSH 服务器的端口号很可能不是22，如果遇到这种情况就需要使用<code>-p</code>选项，指定正确的端口号，否则无法正确连接到服务器</li></ul></blockquote><h4 id="3）Windows-下-SSH-客户端的安装"><a href="#3）Windows-下-SSH-客户端的安装" class="headerlink" title="3）Windows 下 SSH 客户端的安装"></a>3）Windows 下 SSH 客户端的安装</h4><ul><li><code>Putty</code><a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html" target="_blank" rel="noopener">https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html</a></li><li><code>SHeLL</code><a href="http://xshellcn.com" target="_blank" rel="noopener">http://xshellcn.com</a></li></ul><blockquote><p>建议从官方网站下载</p></blockquote><h3 id="3-2-scp（掌握）"><a href="#3-2-scp（掌握）" class="headerlink" title="3.2 scp（掌握）"></a>3.2 scp（掌握）</h3><ul><li>scp就是<code>secure copy</code>，是一个在Linux下用来远程拷贝的命令</li><li>它的地址格式与ssh基本相同，需要注意的是，在指定端口时是大写的<code>-P</code>而不是小写的</li><li>把本地文件拷贝到远程服务器，也可以把远程文件拷贝到本地</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 把本地当前目录下的 01.py 文件复制到远程家目录下的 Desktop/01.py</span><br><span class="line"># 注意：后面的路径如果不是绝对路径，则用户的家目录作为参考路径</span><br><span class="line">$ scp -P port 01.py user@remote:Desktop/01.py</span><br><span class="line"></span><br><span class="line"># 把远程家目录下的的 Desktop/01.py 复制到本地当前目录下的 01.py</span><br><span class="line">$ scp -P port user@remote:Desktop/01.py 01.py</span><br><span class="line"></span><br><span class="line"># 加上 -r 选项可以传送文件夹</span><br><span class="line"># 把当前目录下的 demo 文件夹复制到远程远程家目录下的 Desktop</span><br><span class="line">$ scp -r demo user@remote:Desktop</span><br><span class="line"></span><br><span class="line"># 把远程家目录下的 Desktop 复制到当前目录下的 demo 文件</span><br><span class="line">$ scp -r user@remote:Desktop demo</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-r</td><td>若给出的文件是目录文件，则scp<br>将递归复制该目录下的所有文件和目录，目标文件必须为一个目录名</td></tr><tr><td>-P</td><td>若远程SSH服务器的端口不是22，则需要大写字母-P选项指定端口</td></tr></tbody></table><blockquote><p>注意：</p><ul><li><code>scp</code>这个终端命令只能在<code>Linux</code>或者<code>UNIX</code>系统下使用</li><li>如果在<code>Windouws</code>系统中，可以安装<code>PuTTY</code>，使用<code>pscp</code>命令行工具，或者安装<code>FileZilla</code>使用<code>FTP</code>进行文件传输</li></ul><p><strong>FileZilla</strong></p><ul><li>官方网站：<a href="https://www.filezilla.cn.download/client" target="_blank" rel="noopener">https://www.filezilla.cn.download/client</a></li><li><code>FileZilla</code>在传输文件时，使用的是<code>FTP 服务</code>而不是<code>SSH 服务</code>因此端口号应该设置为<code>21</code></li></ul></blockquote><h3 id="3-3-SSH高级（知道）"><a href="#3-3-SSH高级（知道）" class="headerlink" title="3.3 SSH高级（知道）"></a>3.3 SSH高级（知道）</h3><ul><li>免密码登录</li><li>配置别名</li></ul><blockquote><p><strong><em>提示</em></strong> ：有关<strong>SSH 配置信息</strong>都保存在用户家目录下的<code>.SSH</code>目录下</p></blockquote><h4 id="1）免密码登录"><a href="#1）免密码登录" class="headerlink" title="1）免密码登录"></a>1）免密码登录</h4><p><strong>步骤</strong></p><ul><li>配置公钥<ul><li>执行 <code>ssh-keygen</code> 即可生成 SSH 钥匙，一路回车即可</li></ul></li><li><p>上传公钥到服务器</p><ul><li>执行 <code>ssh-copy-id -p port user@remote</code>，可以让远程服务器记住我们的公钥</li></ul></li><li><p>示意图</p></li></ul><blockquote><p>非对称加密算法</p><ul><li>使用<strong>公钥</strong>加密的数据，需要使用<strong>私钥</strong>解密</li><li>使用<strong>私钥</strong>加密的数据，需要使用<strong>公钥</strong>解密</li><li>本地使用私钥对数据加密/解密</li><li>服务器使用公钥对数据加密/解密</li></ul></blockquote><h4 id="2）配置别名"><a href="#2）配置别名" class="headerlink" title="2）配置别名"></a>2）配置别名</h4><p>每次输入 <code>ssh -p port user@remote</code>，时间久了会很麻烦，而且当 <code>user</code>，<code>remote</code> 和 <code>port</code>都需要输入，还不好记忆</p><p>而 <strong>配置别名</strong> 可以让我们进一步偷懒，例如用：<code>ssh max</code> 来代替上面这么一长串，那么就在 <code>~/.ssh/config</code> 里面追加以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host mac</span><br><span class="line">HostName ip地址</span><br><span class="line">user itheima</span><br><span class="line">Port 22</span><br></pre></td></tr></table></figure><p><strong>保存之后，即可使用</strong> <code>ssh mac</code> <strong>实现远程登录</strong>，<code>scp</code> <strong>同样可以使用</strong></p><h1 id="8、用户权限相关命令"><a href="#8、用户权限相关命令" class="headerlink" title="8、用户权限相关命令"></a>8、用户权限相关命令</h1><h2 id="目标-7"><a href="#目标-7" class="headerlink" title="目标"></a>目标</h2><ul><li><strong>用户</strong> 和 <strong>权限</strong> 的基本概念</li><li><strong>用户管理</strong> 终端命令</li><li><strong>组管理</strong> 终端命令</li><li><strong>修改权限</strong> 终端命令</li></ul><h2 id="01-用户和权限的基本概念"><a href="#01-用户和权限的基本概念" class="headerlink" title="01 用户和权限的基本概念"></a>01 用户和权限的基本概念</h2><h3 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h3><ul><li>用户是 Linux 中重要的一环，用户环境包括 <strong>用户</strong> 与 <strong>组管理</strong></li><li>在 Linux 系统中，不论是本机或者远程登录系统，每个系统必须<strong>拥有一个账号，并且对不同的系统资源拥有不同的使用权限</strong></li><li>在 Linux 中，可以指定 <strong>每一个用户</strong> 针对 <strong>不同的文件或者目录</strong> 的 <strong>不同权限</strong></li><li>对 <strong>文件/目录</strong> 的权限包括：</li></ul><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:center">权限</th><th style="text-align:center">英文</th><th style="text-align:center">缩写</th><th style="text-align:center">数字代号</th></tr></thead><tbody><tr><td style="text-align:left">01</td><td style="text-align:center">读</td><td style="text-align:center">read</td><td style="text-align:center">r</td><td style="text-align:center">4</td></tr><tr><td style="text-align:left">02</td><td style="text-align:center">写</td><td style="text-align:center">write</td><td style="text-align:center">w</td><td style="text-align:center">2</td></tr><tr><td style="text-align:left">03</td><td style="text-align:center">执行</td><td style="text-align:center">excute</td><td style="text-align:center">x</td><td style="text-align:center">1</td></tr><tr><td style="text-align:left">04</td><td style="text-align:center">无权限</td><td style="text-align:center"></td><td style="text-align:center">-</td><td style="text-align:center">0</td></tr></tbody></table><h3 id="1-2-组"><a href="#1-2-组" class="headerlink" title="1.2 组"></a>1.2 组</h3><ul><li>为了方便用户管理，提出了 <strong>组</strong> 的概念</li><li>在实际应用中，可以预见对 <strong>组</strong> 设置好权限，然后 <strong>将不同的用户添加到对应的组中</strong>，从而 <strong>不用一次为每一个用户设置权限</strong></li></ul><h3 id="1-3-ls-l-扩展"><a href="#1-3-ls-l-扩展" class="headerlink" title="1.3 ls -l 扩展"></a>1.3 ls -l 扩展</h3><ul><li><p><code>ls -l</code> 可以查看文件的详细信息，从左到右依次是：</p><ul><li><strong>权限</strong> 第一个字符如果是 <code>d</code> 表示目录</li><li><strong>硬链接数</strong> 通俗的讲，就是有多少种方式，可以访问当前目录/文件</li><li><strong>拥有者</strong> 家目录下 文件/目录 的拥有者通常都是当前用户</li><li><strong>组</strong> 在 Linux 中，很多时候，会出现组名和用户名相同的情况</li><li><strong>大小</strong></li><li><strong>时间</strong></li><li><p><strong>名称</strong> </p><pre><code>目录     拥有者权限      组权限          其他用户权限</code></pre></li></ul></li></ul><p>文件权限提示        -           r    w     -        r     w    -        r       -        -</p><p>目录权限提示        d         r     w     x       r     w    x       r       -        x</p><h3 id="1-4-chmod-简单使用（重要）"><a href="#1-4-chmod-简单使用（重要）" class="headerlink" title="1.4 chmod 简单使用（重要）"></a>1.4 chmod 简单使用（重要）</h3><ul><li><code>chmod</code> 可以修改 <strong>用户/组</strong> 对 <strong>文件/目录</strong> 的权限</li><li>命令格式如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +/-rwx 文件名|目录名</span><br></pre></td></tr></table></figure><blockquote><p>提示：以上方式会一次性修改 <code>拥有者</code> / <code>组</code> 权限</p><p>注意：目录的 <code>读</code> 是 <code>ls</code> ，<code>写</code> 是 <code>touch mkdir</code></p></blockquote><p>1.5 超级用户</p><p>1.5 超级用户</p><h3 id="1-5-超级用户"><a href="#1-5-超级用户" class="headerlink" title="1.5 超级用户"></a>1.5 超级用户</h3><ul><li>Linux 系统中的 <code>root</code> 账号通常用于 <strong>系统的管理和维护</strong>，对操作系统的所有资源 <strong>具有所有访问权限</strong></li><li>在大多数版本的 Linux 中，都不推荐直接使用 <strong>root</strong> 账号直接登录</li><li>在 Linux 安装的过程中，系统会自动创建一个用户账号，而这个默认的用户就称为“标准用户”</li></ul><p><strong>sudo</strong></p><ul><li><code>su</code> 是 <code>substitute user</code> 的缩写，表示 <strong>使用另个一个用户的身份</strong></li><li><code>sudo</code> 命令用其他用户来执行时，预设身份是 <code>root</code></li><li>用户使用 <code>sudo</code> 时，必须先输入密码，之后 <strong>5分钟之内有效</strong>，超过期限必须重新输入密码</li></ul><blockquote><p><em>若未经授权的用户企图使用</em> <code>sudo</code>，<em>则会发出警告邮件给管理员</em></p></blockquote><h2 id="02-组管理终端命令"><a href="#02-组管理终端命令" class="headerlink" title="02 组管理终端命令"></a>02 组管理终端命令</h2><blockquote><p><em>提示：<strong>创建组/删除组</strong> 的终端命令都需要通过 <code>sudo</code> 来执行</em></p></blockquote><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>groupadd 组名</td><td>添加组</td></tr><tr><td>02</td><td>groupdel 组名</td><td>删除组</td></tr><tr><td>03</td><td>cat /etc/group</td><td>确认组信息</td></tr><tr><td>04</td><td>chgrp 组名 文件名/目录名</td><td>修改文件/目录的所属组</td></tr></tbody></table><blockquote><p>提示：</p><ul><li>组信息保留在 <code>/etc/group</code> 文件中</li><li><code>/etc</code> 目录是专门用来保存 <strong>系统配置信息</strong> 的目录</li></ul></blockquote><ul><li>在实际应用中，可以预先对 <strong>组</strong> 设置好权限，然后将不同的用户添加到对应的组中，从而不用依次为每一个设置权限</li></ul><p><strong>演练目标</strong></p><p>1、在 <code>python</code> 用户的桌面文件夹下创建 <code>python学习</code> 目录</p><p>2、新建 <code>dev</code> 组</p><p>3、<code>将 python学习</code> 组修改为 <code>dev</code></p><h2 id="03-用户管理终端命令"><a href="#03-用户管理终端命令" class="headerlink" title="03 用户管理终端命令"></a>03 用户管理终端命令</h2><blockquote><p>提示：<strong>创建用户/删除用户/修改其他用户密码</strong> 的终端命令都需要通过 <code>sudo</code> 执行</p></blockquote><h3 id="3-1-创建用户-删除用户-修改其他用户密码"><a href="#3-1-创建用户-删除用户-修改其他用户密码" class="headerlink" title="3.1 创建用户/删除用户/修改其他用户密码"></a>3.1 创建用户/删除用户/修改其他用户密码</h3><table><thead><tr><th style="text-align:left">序号</th><th>命令</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left">01</td><td>useradd -m -g <br>新建用户名</td><td>添加新用户</td><td>-m 自动建立用户家目录<br>-g 指定用户目录所在的组，否则会建一个和同名的组</td></tr><tr><td style="text-align:left">02</td><td>passwd 用户名</td><td>设置用户密码</td><td>如果是普通用户，直接使用 passwd<br>可以修改自己的账户密码</td></tr><tr><td style="text-align:left">03</td><td>userdel -r 用户名</td><td>删除用户</td><td>-r 选项会自动删除用户家目录</td></tr><tr><td style="text-align:left">04</td><td>cat /etc/passwd  <br>\</td><td>grep 用户名</td><td>确认用户信息</td><td>新建用户后，用户信息会保存在 /etc/passwd 文件中</td></tr></tbody></table><blockquote><p>提示：</p><ul><li>创建用户时，如果忘记加 <code>-m</code> 选项指定新用户的家目录，–最简单的方法就是 <strong>删除新用户，重新创建</strong></li><li>创建用户时，会默认的创建一个和 <strong>用户名</strong> 同名的 <strong>组名</strong></li><li>用户信息保存在 <code>/etc/passwd</code> 中</li></ul></blockquote><h3 id="3-2-查看用户信息"><a href="#3-2-查看用户信息" class="headerlink" title="3.2 查看用户信息"></a>3.2 查看用户信息</h3><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>id [用户名]</td><td>查看用户UID和GID信息</td></tr><tr><td>02</td><td>who</td><td>查看当前所有登录的用户列表</td></tr><tr><td>03</td><td>whoami</td><td>查看当前登录用户的账户名</td></tr></tbody></table><h4 id="passwd-文件"><a href="#passwd-文件" class="headerlink" title="passwd 文件"></a>passwd 文件</h4><p><code>/etc/passwd</code> 文件存放的是用户的信息，由6个分号组成的7个信息，分别是</p><ol><li>用户名</li><li>密码（x，表示加密的密码）</li><li>UID （用户标识）</li><li>GID （组标识）</li><li>用户全名或本地账户</li><li>家目录</li><li>登录使用的Shell，就是登录之后使用的终端命令，<code>ubuntu</code> 默认是 <code>dash</code></li></ol><h4 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h4><ul><li><code>usermod</code> 可以用来设置 <strong>用户</strong> 的 <strong>主组/副组</strong> 和登录 <strong>Shell</strong>，命令格式如下：</li><li><strong>主组</strong>：通常在新建用户时指定，在 <code>etc/passwd</code> 的第四列 <strong>GID 对应的组</strong></li><li><strong>附加组</strong>：在 <code>etc/group</code> 中最后一列表示该组的用户列表，用于指定用户附加权限</li></ul><blockquote><p>提示：设置了用户的附加组之后，需要用户重新登录才能生效</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 修改用户的主组 （passwd 中的 GIU）</span><br><span class="line">$ usermod -g 组 用户名</span><br><span class="line"></span><br><span class="line"># 修改用户的附加组</span><br><span class="line">$ usermod -G 组 用户名</span><br><span class="line"></span><br><span class="line"># 修改用户登录 Shell</span><br><span class="line">$ usermod -s /bin/bash</span><br></pre></td></tr></table></figure><blockquote><p>注意：默认使用的 <code>useradd</code> 添加的用户是没有权限使用 <code>sudo</code> 以 <code>root</code> 身份执行命令的，可以使用以下命令，将用户添加到 <code>sudo</code>附件中</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -G sudo 用户名</span><br></pre></td></tr></table></figure><h4 id="which（重要）"><a href="#which（重要）" class="headerlink" title="which（重要）"></a>which（重要）</h4><blockquote><p><strong><em>提示</em></strong></p><ul><li><code>/etc/passwd</code> 是用于保存用户信息的文件</li><li><code>/user/bin/passwd</code> 是用于修改用户密码的程序</li></ul></blockquote><ul><li><code>which</code> 命令可以查看执行命令所在的位置，例如：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">which ls</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line"># /bin/ls</span><br><span class="line"></span><br><span class="line">which useradd</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line"># /user/sbin/useradd</span><br></pre></td></tr></table></figure><h4 id="bin-和-sbin"><a href="#bin-和-sbin" class="headerlink" title="bin 和 sbin"></a>bin 和 sbin</h4><ul><li>在 <code>Linux</code> 中，绝大数可执行文件都是保存在 <code>/bin</code>、<code>/sbin</code>、<code>/user/bin</code>、<code>/user/sbin</code></li><li><code>/bin</code> （<code>binary</code>）是二进制可执行文件目录，主要用于具体应用</li><li><code>/sbin</code> （<code>system binary</code>）是系统管理员专用的二进制代码存放目录，主要用于系统管理</li><li><code>user/bin</code> （<code>user commds for applications</code>）后期安装的一些软件</li><li><code>user/sbin</code> （<code>super user commds for applications</code>）超级用户的一些管理程序</li></ul><blockquote><p>提升：</p><ul><li><code>cd</code> 这个终端命令是内置在系统内核当中的，没有独立的文件，因此无法用 <code>which</code> 查找 <code>cd</code> 命令位置</li></ul></blockquote><h3 id="3-3-切换用户"><a href="#3-3-切换用户" class="headerlink" title="3.3 切换用户"></a>3.3 切换用户</h3><table><thead><tr><th>序号</th><th>命令</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>01</td><td>su -用户</td><td>切换用户，并且切换目录</td><td>- 可以切换到用户家目录，否则保持位置不变</td></tr><tr><td>02</td><td>exit</td><td>退出当前登录用户</td></tr></tbody></table><ul><li><code>su</code> 不接用户名，可以切换到<code>root</code> 但是不推荐使用，因为不安全</li><li><code>exit</code> 的使用类似于函数调用，跳转到别的用户，<code>exit</code> 退出到从上一个用户切换到当前用户，如果没有切换用户，则 <code>exit</code> 退出终端</li></ul><h2 id="04-修改文件权限"><a href="#04-修改文件权限" class="headerlink" title="04 修改文件权限"></a>04 修改文件权限</h2><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>chown</td><td>修改拥有者</td></tr><tr><td>02</td><td>chgrp</td><td>修改组</td></tr><tr><td>03</td><td>chmod</td><td>修改权限</td></tr></tbody></table><ul><li>命令格式如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 修改文件|目录的拥有者</span><br><span class="line">$ chown 用户名 文件名|目录名</span><br><span class="line"></span><br><span class="line"># 递归修改文件|目录的组</span><br><span class="line">$ chgrp -R 组名 文件名|组名</span><br><span class="line"></span><br><span class="line"># 递归修改文件权限</span><br><span class="line">$ chmod -R 755 文件名|目录名</span><br></pre></td></tr></table></figure><ul><li><code>chmod</code> 在设置权限时，可以简单的使用三个数字分别对应 <strong>拥有者 / 组</strong> 和 <strong>其他</strong> 用户权限</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 直接修改文件|目录的 读|写|执行 权限，但是不能精确测量到 拥有者|组|其他|</span><br><span class="line">$ chmod +/-rwx 文件名|目录名</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">拥有者</th><th style="text-align:center">组</th><th style="text-align:center">其他</th></tr></thead><tbody><tr><td style="text-align:center">r         w            x</td><td style="text-align:center">r         w            x</td><td style="text-align:center">r         w            x</td></tr><tr><td style="text-align:center">4         2            1</td><td style="text-align:center">4         2            1</td><td style="text-align:center">4         2            1</td></tr></tbody></table><table><thead><tr><th style="text-align:center">r</th><th style="text-align:center">w</th><th style="text-align:center">x</th><th style="text-align:center"></th><th style="text-align:center">数字</th><th style="text-align:center"></th><th style="text-align:center">代表含义</th></tr></thead><tbody><tr><td style="text-align:center">4</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center">7</td><td style="text-align:center"></td><td style="text-align:center">rwx</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center"></td><td style="text-align:center">6</td><td style="text-align:center"></td><td style="text-align:center">rw-</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center">5</td><td style="text-align:center"></td><td style="text-align:center">r-x</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center"></td><td style="text-align:center">4</td><td style="text-align:center"></td><td style="text-align:center">r–</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center">3</td><td style="text-align:center"></td><td style="text-align:center">-wx</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center"></td><td style="text-align:center">2</td><td style="text-align:center"></td><td style="text-align:center">-w-</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center">–x</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center"></td><td style="text-align:center">—</td></tr></tbody></table><ul><li>常见的数字组合（<code>u</code> 代表用户 / <code>g</code> 代表组 / <code>o</code> 表示其他）：<ul><li><code>777</code> ===&gt; <code>u=rwx, g=rwx, o=rwx</code></li><li><code>755</code> ===&gt; <code>u=rwx,  g=rx, o=rx</code></li><li><code>644</code> ===&gt; <code>u=rw, g=r, p=r</code></li></ul></li></ul><p><strong>chomd 演练目标</strong></p><ol><li>将 <code>01.py</code> 的权限修改为 <code>u=rwx, g=rx, o=r</code></li><li>将 <code>123.txt</code> 的权限修改为 <code>u=rw, g=r, o=-</code></li><li>将 <code>test</code> 目录及目录下的 <strong>所有文件权限修改为</strong> <code>u=rwx, g=rwx, o=rx</code></li></ol><h1 id="9、系统信息相关命令"><a href="#9、系统信息相关命令" class="headerlink" title="9、系统信息相关命令"></a>9、系统信息相关命令</h1><ul><li>本节内容主要是为了方便通过远程终端维护服务器时，查看服务器上当前 <strong>系统日期时间 / 磁盘空间 / 占用情况 / 程序执行情况</strong></li><li>本小节学习的终端命令基本都是查询命令，通过对这些命令对系统资源的使用情况有各了解</li></ul><h2 id="目标-8"><a href="#目标-8" class="headerlink" title="目标"></a>目标</h2><ul><li>时间和日期<ul><li><code>date</code></li><li><code>cal</code></li></ul></li><li>磁盘和目录空间<ul><li><code>df</code></li><li><code>du</code></li></ul></li><li>进程信息<ul><li><code>ps</code></li><li><code>top</code></li><li><code>kill</code></li></ul></li></ul><h2 id="01-时间和日期"><a href="#01-时间和日期" class="headerlink" title="01 时间和日期"></a>01 时间和日期</h2><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>cal</td><td>查看日历，-y 选项可以查看一年的日历</td></tr><tr><td>02</td><td>date</td><td>查看系统时间</td></tr></tbody></table><h2 id="02-磁盘信息"><a href="#02-磁盘信息" class="headerlink" title="02 磁盘信息"></a>02 磁盘信息</h2><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>df -h</td><td>disk free 显示磁盘剩余空间</td></tr><tr><td>02</td><td>du -h [目录名]</td><td>disk usage 显示目录下的文件大小</td></tr></tbody></table><ul><li>选项说明</li></ul><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-h</td><td>以人性化的方式显示文件大小</td></tr></tbody></table><h2 id="03-进程信息"><a href="#03-进程信息" class="headerlink" title="03 进程信息"></a>03 进程信息</h2><ul><li>所谓 <strong>进程</strong>，通俗的讲就是 <strong>当前正在执行的一个程序</strong></li></ul><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>ps aux</td><td>process status 查看进程的详细信息</td></tr><tr><td>02</td><td>top</td><td>动态显示运行中的程序并排序</td></tr><tr><td>03</td><td>kill [-9] 进程代号</td><td>终止指定程序的进程，-9表示强行终止</td></tr></tbody></table><blockquote><p><code>ps</code> 默认会显示当前用户通过终端启动的应用程序</p></blockquote><ul><li><code>ps</code> 选项说明功能</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>a</td><td>显示终端上的所有进程，包括其他用户的进程</td></tr><tr><td>u</td><td>显示进程的详细状态</td></tr><tr><td>x</td><td>显示没有控制终端的进程</td></tr></tbody></table><blockquote><p>提升：使用 <code>kill</code> 命令时，最好只终止由当前用户开启的进程，而不要终止 <code>root</code> 身份开启的进程，否则有可能导致系统崩溃</p></blockquote><h1 id="10、其他命令"><a href="#10、其他命令" class="headerlink" title="10、其他命令"></a>10、其他命令</h1><h2 id="目标-9"><a href="#目标-9" class="headerlink" title="目标"></a>目标</h2><ul><li>查找文件<ul><li><code>find</code></li></ul></li><li>软连接<ul><li><code>ln</code></li></ul></li><li>打包和压缩<ul><li><code>tar</code></li></ul></li><li>软件安装<ul><li><code>apt-get</code></li></ul></li></ul><h2 id="01-查找文件"><a href="#01-查找文件" class="headerlink" title="01 查找文件"></a>01 查找文件</h2><ul><li><code>find</code> 命令的功能非常强大，通常用来在 <strong>特定的指定目录下</strong> <strong>搜索</strong> 符合条件的文件</li></ul><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>find [路径] -name “*.py”</td><td>查找指定路径下扩展名是.py的文件，包括子目录</td></tr></tbody></table><ul><li>如果省略路径，表示在当前路径下查找</li><li>之前学习的通配符，在使用 <code>find</code> 命令时同时可用</li></ul><p><strong>演练目标</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 搜索桌面目录下，文件名包含 1 的文件</span><br><span class="line">$ find Desktop/ -name &quot;*1*&quot; </span><br><span class="line"></span><br><span class="line"># 搜索桌面目录下，所有以 .txt 为扩展名的文件</span><br><span class="line">$ find Desktop/ -name &quot;*.txt&quot;</span><br><span class="line"></span><br><span class="line"># 搜索桌面目录下，以数字 1 开头的文件</span><br><span class="line">$ fine Desktop/ -name &quot;1*&quot;</span><br></pre></td></tr></table></figure><h2 id="02-软链接"><a href="#02-软链接" class="headerlink" title="02 软链接"></a>02 软链接</h2><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>ln -s 被链接的源文件 链接文件</td><td>建立文件的软链接，用通俗的方式讲 类似于<br> Windows 下的 快捷方式</td></tr></tbody></table><blockquote><p>注意：</p><ul><li>没有 <code>-s</code> 选项建立的是一个 <strong>硬链接文件</strong><ul><li>两个文件占用相同的大小磁盘空间，工作中几乎<strong>不会建立文件的硬链接</strong></li></ul></li><li><strong>源文件要使用绝对路径</strong>，不能使用相对路径，这样可以方便移动链接文件后，仍然能够正常工作</li></ul></blockquote><p><strong>演练目标</strong></p><ul><li>将桌面目录下的 <code>01.py</code> 移动到 <code>demo/b/c</code> 目录下</li><li><p>在桌面目录下新建 <code>01.py</code> 的软链接 <code>FistPython</code></p><ul><li>分别使用 <strong>相对路径</strong> 和 <strong>绝对路径</strong> 建立软链接</li></ul></li><li><p>将 <code>FistPython</code> 移动到 <code>demo</code> 目录下，对比使用 <strong>相对路径</strong> 和 <strong>绝对路径</strong> 的区别</p></li></ul><p><strong>硬链接简介（知道）</strong></p><ul><li>在使用 <code>ln</code> 创建链接时，如果没有使用 <code>-s</code> 选项，会创建一个 <strong>硬链接</strong>，而不是软链接</li></ul><p><strong>硬链接练习</strong></p><ul><li>在 <code>~/Desktop/demo</code> 目录下建立 <code>~/Desktop/demo/b/c/01.py</code> 的硬链接 <code>01_hard</code></li><li>使用 <code>ls-l</code> 查看文件的 <strong>硬链接数</strong> （硬链接–有多少种方式可以访问文件或者目录）</li><li>删除 <code>~/Desktop/demo/b/c/01.py</code>，并使用 <code>tree</code> 确认 <code>demo</code> 目录下的三个链接文件</li></ul><blockquote><p>在 Linux 中，<strong>文件名</strong> 和 <strong>文件数据</strong> 是分开存储的，有各自的存储地址，文件名存储的是文件数据的地址</p><p>软链接：创建的文件 中存放着 <strong>源文件名</strong> 的存放地址</p><p>硬链接：创建了 <strong>源文件数据</strong> 的存放地址</p></blockquote><ul><li>提示<ul><li>在 Linux 中，只有文件的 <code>硬链接数 == 0</code> 文件才会被删除</li><li>使用 <code>ls -l</code> <strong>可以查看 一个文件的硬链接数量</strong></li><li>在日常工作中，几乎不会建立文件的硬链接，知道即可</li></ul></li></ul><h2 id="03-打包和压缩"><a href="#03-打包和压缩" class="headerlink" title="03 打包和压缩"></a>03 打包和压缩</h2><ul><li><strong>打包压缩</strong> 是日常工作中备份文件的一种方式</li><li>在不同的操作系统中，常用的打包压缩方式是不同的<ul><li><code>Windows</code> 常用 <code>rar</code></li><li><code>Mac</code> 常用 <code>zip</code></li><li><code>Linux</code> 常用 <code>tar.gz</code></li></ul></li></ul><h3 id="3-1-打包-解包"><a href="#3-1-打包-解包" class="headerlink" title="3.1 打包 / 解包"></a>3.1 打包 / 解包</h3><ul><li><code>tar</code> 是 Linux 中最常用的 <strong>备份</strong> 工具，次命令可以 <strong>把一些列文件</strong> 打包到 <strong>一个大文件中</strong>，也可以把一个 <strong>打包的大文件恢复成一些列文件</strong></li><li><code>tar</code> 的命令格式如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 打包文件</span><br><span class="line">$ tar -cvf 打包文件.tar 被打包文件 /路径...</span><br><span class="line"></span><br><span class="line"># 解包文件</span><br><span class="line">$ tar -xvf 打包文件.tar</span><br></pre></td></tr></table></figure><ul><li><code>tar</code> 选项说明</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>c</td><td>生成档案文件，创建打包文件</td></tr><tr><td>x</td><td>解开档案文件</td></tr><tr><td>v</td><td>列出归档解档详细过程，显示进度</td></tr><tr><td>f</td><td>指定档案文件名称后，f 后面一定是 .tar 文件，所以必须放在选项最后</td></tr></tbody></table><blockquote><p>注意：<code>f</code> 选项必须放在最后，其他选项顺序可以随意</p></blockquote><p><strong>打包解包联系</strong></p><ol><li>删除桌面下所有内容</li><li>在桌面下新建三个空白文件 <code>01.py</code>、<code>02.py</code>、<code>03.py</code></li><li>将这三个文件打包成一个 <code>py.tar</code> 的包</li><li>新建 <code>tar</code> 目录，并将 <code>py.tar</code> 移动到 <code>tar</code> 目录下</li><li>解包 <code>py.tar</code></li></ol><h3 id="3-2-压缩-解压缩"><a href="#3-2-压缩-解压缩" class="headerlink" title="3.2 压缩 / 解压缩"></a>3.2 压缩 / 解压缩</h3><h4 id="1）gzip"><a href="#1）gzip" class="headerlink" title="1）gzip"></a>1）gzip</h4><ul><li><code>tar</code> 与 <code>gzip</code> 命令结合可以使用实现文件 <strong>打包和压缩</strong><ul><li><code>tar</code> 只负责打包，但不压缩</li><li>用 <code>gzip</code> 压缩 <code>tar</code> 打包后的文件，其扩展名一般用 <code>xxx.tar.gz</code></li></ul></li></ul><blockquote><p>在 <code>Linux</code> 中，最常见的压缩文件格式就是 <code>xxx.tar.gz</code></p></blockquote><ul><li>在 <code>tar</code> 命令中有一个选项 <code>-z</code> 可以调用 <code>gzip</code> 从而可以方便实现压缩功能</li><li>命令格式如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 压缩文件</span><br><span class="line">$ tar -zcvf 打包文件.tar.gz 被压缩的文件 /路径...</span><br><span class="line"></span><br><span class="line"># 解压缩文件</span><br><span class="line">$ tar -zxvf 打包文件.tar.gz</span><br><span class="line"></span><br><span class="line"># 解压缩到指定路径</span><br><span class="line">$ tar -zxvf 打包文件.tar.gz -C 目标路径</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-C</td><td>解压缩到指定路径，注意：要解压缩的目录必须存在</td></tr></tbody></table><h4 id="2）bzip2（two）"><a href="#2）bzip2（two）" class="headerlink" title="2）bzip2（two）"></a>2）bzip2（two）</h4><ul><li><code>tar</code> 与 <code>bzip2</code> 命令结合可以使用实现文件的 <strong>打包和压缩</strong> （用法和 <code>gzip</code> 一样）<ul><li><code>tar</code> 只负责打包文件，但不压缩</li><li>用 <code>bzip2</code> 压缩 <code>tar</code> 打包后的文件，其扩展名一般用 <code>xxx.tar.bz2</code></li></ul></li><li>在 <code>tar</code> 命令中有一个选项 <code>-j</code> 可以调用 <code>bzip2</code>，从而可以方便实现压缩和解压缩的功能</li><li>命令格式如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 压缩文件</span><br><span class="line">$ tar -jcvf 打包文件.tar.bz2 被压缩的文件 /路径...</span><br><span class="line"></span><br><span class="line"># 解压缩文件</span><br><span class="line">$ tar -jxvf 打包文件.tar.bz2</span><br></pre></td></tr></table></figure><h2 id="04-软件安装"><a href="#04-软件安装" class="headerlink" title="04 软件安装"></a>04 软件安装</h2><h3 id="4-1-通过-apt-安装-卸载软件"><a href="#4-1-通过-apt-安装-卸载软件" class="headerlink" title="4.1 通过 apt 安装 / 卸载软件"></a>4.1 通过 apt 安装 / 卸载软件</h3><ul><li>apt 是 <code>Advanced Packaging Tool</code>，是 Linux 下的一款安装包管理工具</li><li>可以在终端中方便的 <strong>安装 / 卸载 / 更新软件包</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 1. 安装软件</span><br><span class="line">$ sudo apt install 软件包</span><br><span class="line"></span><br><span class="line"># 2. 卸载软件</span><br><span class="line">$ sudo apt remove 软件名</span><br><span class="line"></span><br><span class="line"># 3. 更新已安装的软件包</span><br><span class="line">$ sudo apt upgrade</span><br></pre></td></tr></table></figure><p><strong>安装演练</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 一个小火车提示</span><br><span class="line">$ sudo apt install sl</span><br><span class="line"></span><br><span class="line"># 一个比较漂亮的查看当前进程排名的软件</span><br><span class="line">$ sudo apt install htop</span><br></pre></td></tr></table></figure><h3 id="4-2-配置软件源"><a href="#4-2-配置软件源" class="headerlink" title="4.2 配置软件源"></a>4.2 配置软件源</h3><ul><li>如果希望在 <code>Ubuntu</code> 中安装软件，<strong>更加快速</strong>，可以通过设置 <strong>镜像源</strong>，选择一个网速更快的服务器，来提供软件 <strong>下载 / 安装服务</strong></li><li>提示：更换服务器后，需要一个相对较长时间的更新过程，需要耐心等待。更新完成后，在安装软件都会从新设置的服务器下载软件了</li></ul><blockquote><p>所谓镜像源，就是 <strong>所有服务器的内容是相同的（镜像）</strong>，但是根据所在位置不同，国内的服务器通常速度回更快一些！</p></blockquote><ul><li>设置：软件和更新-&gt;下载自：-&gt;其他站点-&gt;选择最佳服务器-&gt;选择服务器-&gt;授权-&gt;关闭-&gt;重新载入</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1、操作系统&quot;&gt;&lt;a href=&quot;#1、操作系统&quot; class=&quot;headerlink&quot; title=&quot;1、操作系统&quot;&gt;&lt;/a&gt;1、操作系统&lt;/h1&gt;&lt;h2 id=&quot;1-1操作系统简介&quot;&gt;&lt;a href=&quot;#1-1操作系统简介&quot; class=&quot;headerlink&quot; title=&quot;1.1操作系统简介&quot;&gt;&lt;/a&gt;1.1操作系统简介&lt;/h2&gt;
    
    </summary>
    
    
      <category term="主题" scheme="https://www.littlefeng.com/tags/%E4%B8%BB%E9%A2%98/"/>
    
      <category term="Linux" scheme="https://www.littlefeng.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>机器学习常见算法总结</title>
    <link href="https://www.littlefeng.com/2018/09/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://www.littlefeng.com/2018/09/07/机器学习常见算法总结/</id>
    <published>2018-09-07T13:58:00.000Z</published>
    <updated>2018-09-24T15:43:54.737Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>机器学习常见算法总结</p><a id="more"></a><table><thead><tr><th>学习方式</th><th>概念</th></tr></thead><tbody><tr><td>监督式学习</td><td>从给定的训练数据集中学习出一个函数，当新的数据到来时，可以根据此函数预测结果。训练数据集中的目标由人标注的。常见的算法有回归分析和统计分类</td></tr><tr><td>非监督式学习</td><td>与监督式学习相比，训练集没有人为标注的结果，常见的算法有聚类</td></tr><tr><td>半监督式学习</td><td>训练集部分被标识，部分没有被标识。常见的算法有SVM</td></tr><tr><td>强化学习</td><td>输入数据作为模型的反馈，模型对此作出调整。常见的算法有时间差学习</td></tr></tbody></table><table><thead><tr><th>机器学习算法分类</th><th>概念</th></tr></thead><tbody><tr><td>决策树算法</td><td>根据数据属性，采用树状结构建立决策模型。常用来解决分类和回归问题。常见算法：ID3，C4.5，随机森林等</td></tr><tr><td>回归算法</td><td>对连续值预测，如逻辑回归LR等</td></tr><tr><td>分类算法</td><td>对离散值预测，事前已经知道分类，如k-近邻算法</td></tr><tr><td>聚类算法</td><td>对离散值预测，事前对分类未知，如k-means算法</td></tr><tr><td>神经网络</td><td>模拟生物神经网络，可以用来解决分类和回归问题,感知器神经网络(Perceptron Neural Network) ，反向传递(Back Propagation)和深度学习（DL）</td></tr><tr><td>集成算法</td><td>集成几种学习模型进行学习，将最终预测结果进行汇总,Boosting、Bagging、AdaBoost、随机森林 (Random Forest) 等</td></tr></tbody></table><h3 id="机器学习算法分类"><a href="#机器学习算法分类" class="headerlink" title="机器学习算法分类"></a>机器学习算法分类</h3><p>决策树算法<br>根据数据属性，采用树状结构建立决策模型。常用来解决分类和回归问题。<br>常见算法：CART(Classification And Regression Tree)，ID3，C4.5，随机森林等<br>回归算法<br>对连续值预测，如逻辑回归LR等<br>分类算法<br>对离散值预测，事前已经知道分类，如k-近邻算法<br>聚类算法<br>对离散值预测，事前对分类未知，如k-means算法<br>神经网络<br>模拟生物神经网络，可以用来解决分类和回归问题<br>感知器神经网络(Perceptron Neural Network) ，反向传递(Back Propagation)和深度学习（DL）<br>集成算法<br>集成几种学习模型进行学习，将最终预测结果进行汇总<br>Boosting、Bagging、AdaBoost、随机森林 (Random Forest) 等</p><h3 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h3><p>1、SVM不太容易过拟合：松弛因子+损失函数形式</p><p>SVM的求解方法叫拉格朗日乘子法</p><p><img src="/assets/blogImg/svm.jpg" alt=""></p><p>有时候如果你非要很明确地分类，那么结果就会像右边的一样 —— 过拟合。明显左边的两个都比过拟合好多了，可是这样就要求允许一些样本不在正确的类上.</p><blockquote><p>目标：找出总损失值最小并且能大概分类的超平面</p></blockquote><p>2、方法选择<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、如果Feature的数量很大，跟样本数量差不多，这时候选用LR或者是Linear Kernel的SVM</span><br><span class="line">2、如果Feature的数量比较小，样本数量一般，不算大也不算小，选用SVM+Gaussian Kernel</span><br><span class="line">3、如果Feature的数量比较小，而样本数量很多，需要手工添加一些feature变成第一种情况</span><br></pre></td></tr></table></figure></p><p>3、数据维度<br>如果数据特征维度高，svm要使用<strong>核函数</strong>来求解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Note：拉格朗日对偶没有改变最优解，但改变了算法复杂度：原问题—样本维度；对偶问题–样本数量。</span><br><span class="line">线性分类            样本维度&lt;样本数量：原问题求解（liblinear默认）； </span><br><span class="line">非线性–升维—一般导致 样本维度&gt;样本数量：对偶问题求解</span><br></pre></td></tr></table></figure></p><h3 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h3><p>朴素贝叶斯的优点：<br>对小规模的数据表现很好，适合多分类任务，适合增量式训练。<br>缺点：<br>对输入数据的表达形式很敏感（离散、连续，值极大极小之类的）</p><h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><p>线性回归试图学得一个线性模型以尽可能准确地预测实值输出标记。均方误差是回归任务中最常用的性能度量，基于均方误差最小化来进行模型求解的方法成为最小二乘法。在线性回归中，最小二乘法就是试图找到一条直线，使得所有样本到直线上的欧式距离之和最小。这个想法和分类问题是正好相反的，分类问题是找到一个分界面离所有样本尽可能远。</p><p>优化方法</p><p>当x矩阵是列满秩的时候，可以用最小二乘法，但是求矩阵的逆比较慢</p><h2 id="机器学习算法选择"><a href="#机器学习算法选择" class="headerlink" title="机器学习算法选择"></a>机器学习算法选择</h2><blockquote><p>没有最好的分类器，只有最合适的分类器。</p></blockquote><p>数据维度越高，随机森林就比AdaBoost强越多，但是整体不及SVM。</p><p>数据量越大，神经网络就越强。</p><h3 id="1、K近邻"><a href="#1、K近邻" class="headerlink" title="1、K近邻"></a>1、K近邻</h3><p>典型KNN，它的思路就是——对于待判断的点，找到离它最近的几个数据点，根据它们的类型决定待判断点的类型。<br>它的特点是完全跟着数据走，没有数学模型可言。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">适用情景：</span><br><span class="line">需要一个特别容易解释的模型的时候。</span><br><span class="line">比如需要向用户解释原因的推荐算法。</span><br></pre></td></tr></table></figure></p><h3 id="2、贝叶斯"><a href="#2、贝叶斯" class="headerlink" title="2、贝叶斯"></a>2、贝叶斯</h3><p>典型的例子是Naive Bayes，核心思路是根据条件概率计算待判断点的类型。是相对容易理解的一个模型，至今依然被垃圾邮件过滤器使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">适用情景：</span><br><span class="line"></span><br><span class="line">需要一个比较容易解释，而且不同维度之间相关性较小的模型的时候。</span><br><span class="line"></span><br><span class="line">可以高效处理高维数据，虽然结果可能不尽如人意。</span><br></pre></td></tr></table></figure></p><h3 id="3、决策树-Decision-tree"><a href="#3、决策树-Decision-tree" class="headerlink" title="3、决策树 (Decision tree)"></a>3、决策树 (Decision tree)</h3><p>决策树的特点是它总是在沿着特征做切分。随着层层递进，这个划分会越来越细。<br>举个简单的例子，当我们预测一个孩子的身高的时候，决策树的第一层可能是这个孩子的性别。男生走左边的树进行进一步预测，女生则走右边的树。这就说明性别对身高有很强的影响。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">适用情景：</span><br><span class="line">同时它也是相对容易被攻击的分类器。这里的攻击是指人为的改变一些特征，使得分类器判断错误。常见于垃圾邮件躲避检测中。因为决策树最终在底层判断是基于单个条件的，攻击者往往只需要改变很少的特征就可以逃过监测。受限于它的简单性，决策树更大的用处是作为一些更有用的算法的基石。</span><br></pre></td></tr></table></figure><h4 id="随机森林-Random-forest"><a href="#随机森林-Random-forest" class="headerlink" title="随机森林 (Random forest)"></a>随机森林 (Random forest)</h4><p>随机森林其实算是一种集成算法。它首先随机选取不同的特征(feature)和训练样本(training sample)，生成大量的决策树，然后综合这些决策树的结果来进行最终的分类。</p><p>它相对于决策树，在准确性上有了很大的提升，同时一定程度上改善了决策树容易被攻击的特点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">适用情景：</span><br><span class="line"></span><br><span class="line">数据维度相对低（几十维），同时对准确性有较高要求时。</span><br><span class="line"></span><br><span class="line">因为不需要很多参数调整就可以达到不错的效果，基本上不知道用什么方法的时候都可以先试一下随机森林。</span><br></pre></td></tr></table></figure><h3 id="优化问题的求解方法"><a href="#优化问题的求解方法" class="headerlink" title="优化问题的求解方法"></a>优化问题的求解方法</h3><p>大部分的机器学习算法的本质都是建立优化模型，通过最优化方法对目标函数（或损失函数）进行优化，从而训练出最好的模型。常见的最优化方法有梯度下降法、牛顿法和拟牛顿法、共轭梯度法等等。</p><p>1、梯度下降法</p><p>优化思想<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当目标函数是凸函数时，梯度下降法的解是全局解。一般情况下，其解不保证是全局最优解，梯度下降法的速度也未必是最快的。梯度下降法的优化思想是用当前位置负梯度方向作为搜索方向，因为该方向为当前位置的最快下降方向，所以也被称为是”最速下降法“。最速下降法越接近目标值，步长越小，前进越慢。</span><br></pre></td></tr></table></figure></p><p>缺点<br>梯度下降法的最大问题就是会陷入局部最优，靠近极小值时收敛速度减慢。</p><p>2、批量梯度下降法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最小化所有训练样本的损失函数，使得最终求解的是全局的最优解，即求解的参数是使得风险函数最小，但是对于大规模样本问题效率低下。</span><br></pre></td></tr></table></figure></p><p>3、随机梯度下降法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最小化每条样本的损失函数，虽然不是每次迭代得到的损失函数都向着全局最优方向， 但是大的整体的方向是向全局最优解的，最终的结果往往是在全局最优解附近，适用于大规模训练样本情况。</span><br></pre></td></tr></table></figure></p><p>随机梯度下降是通过每个样本来迭代更新一次，如果样本量很大的情况（例如几十万），那么可能只用其中几万条或者几千条的样本，就已经将theta迭代到最优解了，对比上面的批量梯度下降，迭代一次需要用到十几万训练样本，一次迭代不可能最优，如果迭代10次的话就需要遍历训练样本10次。但是，SGD伴随的一个问题是噪音较BGD要多，使得SGD并不是每次迭代都向着整体最优化方向。</p><p>4、牛顿法</p><p>牛顿法是一种在实数域和复数域上近似求解方程的方法。方法使用函数f (x)的泰勒级数的前面几项来寻找方程f (x) = 0的根。牛顿法最大的特点就在于它的收敛速度很快。</p><p>牛顿法比梯度下降法快</p><p>牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法就更快。如果更通俗地说的话，比如你想找一条最短的路径走到一个盆地的最底部，梯度下降法每次只从你当前所处位置选一个坡度最大的方向走一步，牛顿法在选择方向时，不仅会考虑坡度是否够大，还会考虑你走了一步之后，坡度是否会变得更大。所以，可以说牛顿法比梯度下降法看得更远一点，能更快地走到最底部。</p><p>但是牛顿法要算hessian矩阵的逆，比较费时间。</p><p>5、拟牛顿法</p><p>拟牛顿法的本质思想是改善牛顿法每次需要求解复杂的Hessian矩阵的逆矩阵的缺陷，它使用正定矩阵来近似Hessian矩阵的逆，从而简化了运算的复杂度。拟牛顿法和最速下降法一样只要求每一步迭代时知道目标函数的梯度。通过测量梯度的变化，构造一个目标函数的模型使之足以产生超线性收敛性。这类方法大大优于最速下降法，尤其对于困难的问题。另外，因为拟牛顿法不需要二阶导数的信息，所以有时比牛顿法更为有效。</p><p>6、拉格朗日法</p><p>拉格朗日乘数法</p><p>拉格朗日乘子法主要用于解决约束优化问题，它的基本思想就是通过引入拉格朗日乘子来将含有n个变量和k个约束条件的约束优化问题转化为含有（n+k）个变量的无约束优化问题。拉格朗日乘子背后的数学意义是其为约束方程梯度线性组合中每个向量的系数。</p><p>通过引入拉格朗日乘子建立极值条件，对n个变量分别求偏导对应了n个方程，然后加上k个约束条件（对应k个拉格朗日乘子）一起构成包含了（n+k）变量的（n+k）个方程的方程组问题，这样就能根据求方程组的方法对其进行求解</p><p>过拟合：</p><blockquote><p>如果一味的去提高训练数据的预测能力，所选模型的复杂度往往会很高，这种现象称为过拟合。所表现的就是模型训练时候的误差很小，但在测试的时候误差很大。</p></blockquote><p>训练模型很好用，测试时候误差较大</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;机器学习常见算法总结&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://www.littlefeng.com/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>图像边缘检测</title>
    <link href="https://www.littlefeng.com/2018/09/07/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/"/>
    <id>https://www.littlefeng.com/2018/09/07/边缘检测/</id>
    <published>2018-09-07T13:58:00.000Z</published>
    <updated>2018-09-24T15:44:27.454Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="图像边缘检测"><a href="#图像边缘检测" class="headerlink" title="图像边缘检测"></a>图像边缘检测</h3><a id="more"></a><p>常见边缘检测算子：Roberts 、Sobel 、Prewitt、Laplacian、Log/Marr、Canny、Kirsch、Nevitia</p><blockquote><p>一阶微分算子：Roberts 、Sobel 、Prewitt</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">模板：</span><br><span class="line">Roberts  </span><br><span class="line">|1, 0|</span><br><span class="line">|0,-1|</span><br><span class="line"></span><br><span class="line">sobel算子</span><br><span class="line">|1, 0 , 1|</span><br><span class="line">|1, 0 , 1|</span><br><span class="line">|1, 0 , 1|</span><br><span class="line"></span><br><span class="line">prewitt算子</span><br><span class="line">|1, 0 , 1|</span><br><span class="line">|1, 0 , 1|</span><br><span class="line">|1, 0 , 1|</span><br><span class="line"></span><br><span class="line">Sobel各向同性算子:</span><br><span class="line"></span><br><span class="line">   |-1  ,0,  1|     |-1,-1.414,-1|</span><br><span class="line">Gx=|-1.414,0,1.411| ,Gx=| 0,   0, 0|</span><br><span class="line">   |-1  ,0,  1|     | 1, 1.414, 1|</span><br></pre></td></tr></table></figure><p>Sobel各向同性算子的权值比普通Sobel算子的权值更准确。为什么？模板的权值是离中心位置越远则权值（看绝对值）影响越小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">计算边缘幅值与方向？以Sobel算子为例。3*3Sobel两个方向的算子在图像上滑动，模板与其覆盖的图像3*3区域9个像素进行卷积，求和后得到此方向的边缘检测幅值。</span><br><span class="line"></span><br><span class="line">   |-1,0,1|            |-1,-2,-1|</span><br><span class="line">Gx=|-2,0,2|*f(x,y) ,Gx=| 0, 0, 0|*f(x,y)</span><br><span class="line">   |-1,0,1|            | 1, 2, 1|</span><br><span class="line"></span><br><span class="line">G^2=Gx^2+Gy^2</span><br><span class="line"></span><br><span class="line">P=arctan(Gx/Gy)</span><br><span class="line"></span><br><span class="line">f(x,y)为图像，Gx和Gy分别是水平和竖直方向算子的卷积结果，G则是最终得到的边缘幅值，θ值则是边缘方向。当然G的计算有时简化为</span><br><span class="line">G=|Gx|+|Gy| 或者 G=max(|Gx|,|Gy|)</span><br></pre></td></tr></table></figure></p><p>二阶微分算子：Laplacian、Log/Marr<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Laplacian算子</span><br><span class="line">   |-1,-1,-1|      </span><br><span class="line">Gx=|-1, 8,-1|</span><br><span class="line">   |-1,-1,-1|</span><br><span class="line"></span><br><span class="line">   | 0,-1, 0|      </span><br><span class="line">Gx=|-1, 4,-1|</span><br><span class="line">   | 0,-1, 0|</span><br><span class="line"></span><br><span class="line">   |-2,-4,-4,-4,-2|</span><br><span class="line">   |-4, 0, 8, 0,-4|      </span><br><span class="line">Gx=|-4, 8,24, 8,-4|</span><br><span class="line">   |-4, 0, 8, 0,-4|</span><br><span class="line">   |-2,-4,-4,-4,-2|</span><br><span class="line">Log边缘检测则是先进行高斯滤波再进行拉普拉斯算子检测</span><br></pre></td></tr></table></figure></p><p>非微分边缘检测算子：Canny</p><table><thead><tr><th>算 子</th><th>优缺点比较</th></tr></thead><tbody><tr><td>Roberts</td><td>对具有陡峭的低噪声的图像处理效果较好，但利用 Roberts算子提取边缘的结果是边缘比较粗，因此边缘定位不是很准确。</td></tr><tr><td>Sobel</td><td>对灰度渐变和噪声较多的图像处理效果比较好， Sobel算子对边缘定位比较准确。</td></tr><tr><td>Kirsch</td><td>对灰度渐变和噪声较多的图像处理效果较好。</td></tr><tr><td>Prewitt</td><td>对灰度渐变和噪声较多的图像处理效果较好。</td></tr><tr><td>aplacian</td><td>对图像中的阶跃性边缘点定位准确，对噪声非常敏感，丢失一部分边缘的方向信息，造成一些不连续的检测边缘。</td></tr><tr><td>LoG</td><td>算 子 经 常 出 现 双 边 缘 像 素 边 界 ， 而 且 该 检 测 方 法 对 噪 声 比铰 敏 感 ， 所 以 很 少 用 LoG算 子 检 测 边 缘 ， 而 是 用 来 判 断 边 缘 像素是位于图像的明区还是暗区。</td></tr><tr><td>Canny</td><td>此方法不容易受噪声的干扰，能够检测到真正的弱边缘。在edge函数中，最有效的边缘检测方法是 Canny方法。该方法的优点在于使用两种不同的阈值分别检测强边缘和弱边缘，并且汉当弱边缘与强边缘相连时，才将弱边缘包含在输出图像中。因此，这种方法不容易被噪声“填充”，跟容易检测出真正的弱边缘。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;图像边缘检测&quot;&gt;&lt;a href=&quot;#图像边缘检测&quot; class=&quot;headerlink&quot; title=&quot;图像边缘检测&quot;&gt;&lt;/a&gt;图像边缘检测&lt;/h3&gt;
    
    </summary>
    
    
      <category term="图像处理" scheme="https://www.littlefeng.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>图像特征</title>
    <link href="https://www.littlefeng.com/2017/12/06/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/"/>
    <id>https://www.littlefeng.com/2017/12/06/特征提取/</id>
    <published>2017-12-06T13:58:00.000Z</published>
    <updated>2018-09-24T15:44:15.001Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-局部特征"><a href="#1-局部特征" class="headerlink" title="1 局部特征"></a>1 局部特征</h2><p>LOG,HOG,DOG微分算子在近圆的斑点检测方面效果很好</p><a id="more"></a><h3 id="HOG特征"><a href="#HOG特征" class="headerlink" title="HOG特征"></a>HOG特征</h3><p><a href="https://blog.csdn.net/coming_is_winter/article/details/72850511" target="_blank" rel="noopener">https://blog.csdn.net/coming_is_winter/article/details/72850511</a><br><a href="https://blog.csdn.net/zouxy09/article/details/7929348/" target="_blank" rel="noopener">https://blog.csdn.net/zouxy09/article/details/7929348/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">总结：Dalal提出的Hog特征提取的过程：把样本图像分割为若干个像素的单元（cell），把梯度方向平均划分为9个区间（bin），在每个单元里面对所有像素的梯度方向在各个方向区间进行直方图统计，得到一个9维的特征向量，每相邻的4个单元构成一个块（block），把一个块内的特征向量联起来得到36维的特征向量，用块对样本图像进行扫描，扫描步长为一个单元。最后将所有块的特征串联起来，就得到了人体的特征。</span><br><span class="line"></span><br><span class="line">例如，对于64*128的图像而言，每16*16的像素组成一个cell，每2*2个cell组成一个块，因为每个cell有9个特征，所以每个块内有4*9=36个特征，以8个像素为步长，那么，水平方向将有7个扫描窗口，垂直方向将有15个扫描窗口。也就是说，64*128的图片，总共有36*7*15=3780个特征。</span><br><span class="line"></span><br><span class="line">特征总数： 一个cell有9个特征（9个梯度方向），每个特征cell块里有 num*9个特征，步长像素规格：（列像素数-步长）/步长*（行像素数-步长）/步长，</span><br><span class="line">总特征数:（列像素数-步长）/步长*（行像素数-步长）/步长*num*9</span><br></pre></td></tr></table></figure><h3 id="LOG特征"><a href="#LOG特征" class="headerlink" title="LOG特征"></a>LOG特征</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">图像与某一个二维函数进行卷积运算实际就是求取图像与这一函数的相似性。同理，图像与高斯拉普拉斯函数的卷积实际就是求取图像与高斯拉普拉斯函数的相似性。当图像中的斑点尺寸与高斯拉普拉斯函数的形状趋近一致时，图像的拉普拉斯响应达到最大。</span><br></pre></td></tr></table></figure><p>Laplace可以用来检测图像中的局部极值点，但是对噪声敏感，所以在我们对图像进行Laplace卷积之前，我们用一个高斯低通滤波对图像进行卷积，目标是去除图像中的噪声点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">先对图像f(x,y)用方差为σ的高斯核进行高斯滤波，去除图像中的噪点。</span><br><span class="line"></span><br><span class="line">L(x,y;σ)=f(x,y)∗G(x,y;σ)</span><br><span class="line">G(x,y;σ)高斯核</span><br><span class="line">然后对图像的拉普拉斯图像则为：</span><br><span class="line"></span><br><span class="line">∇^2=(∂^2L/∂^x2)+(∂^2L/∂y^2)</span><br><span class="line">而实际上有下面等式：</span><br><span class="line"></span><br><span class="line">∇^2[G(x,y)∗f(x,y)]=∇^2[G(x,y)]∗f(x,y)</span><br><span class="line"></span><br><span class="line">我们可以先求高斯核的拉普拉斯算子，再对图像进行卷积</span><br></pre></td></tr></table></figure></p><blockquote><p>使用LoG虽然能较好的检测到图像中的特征点，但是其运算量过大，通常可使用DoG（差分高斯，Difference of Gaussina）来近似计算LoG</p></blockquote><h3 id="Haar特征"><a href="#Haar特征" class="headerlink" title="Haar特征"></a>Haar特征</h3><p>Haar特征分为三类：边缘特征、线性特征、中心特征和对角线特征，组合成特征模板。特征模板内有白色和黑色两种矩形，并定义该模板的特征值为</p><h3>白色矩形像素和减去黑色矩形像素和</h3><p></p><h3 id="Haar-like特征"><a href="#Haar-like特征" class="headerlink" title="Haar-like特征"></a>Haar-like特征</h3><p><a href="https://blog.csdn.net/zouxy09/article/details/7929570" target="_blank" rel="noopener">https://blog.csdn.net/zouxy09/article/details/7929570</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">积分图就是只遍历一次图像就可以求出图像中所有区域像素和的快速算法，大大的提高了图像特征值计算的效率。</span><br><span class="line"></span><br><span class="line">       积分图主要的思想是将图像从起点开始到各个点所形成的矩形区域像素之和作为一个数组的元素保存在内存中，当要计算某个区域的像素和时可以直接索引数组的元素，不用重新计算这个区域的像素和，从而加快了计算（这有个相应的称呼，叫做动态规划算法）。积分图能够在多种尺度下，使用相同的时间（常数时间）来计算不同的特征，因此大大提高了检测速度。</span><br><span class="line"></span><br><span class="line">       我们来看看它是怎么做到的。</span><br><span class="line"></span><br><span class="line">       积分图是一种能够描述全局信息的矩阵表示方法。积分图的构造方式是位置（i,j）处的值ii(i,j)是原图像(i,j)左上角方向所有像素的和：</span><br></pre></td></tr></table></figure><p>归一化图像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i¯(x,y)=(i(x,y)−μ)/cσ</span><br><span class="line">公式中i¯(x,y)表示归一化之后的图像，而i(x,y)表示原始的图像，其中μ表示图像的均值，而σ表示图像的标准差</span><br><span class="line">σ2=(1/N)∑x2−μ2   2是平方</span><br></pre></td></tr></table></figure></p><h3 id="SIFT特征"><a href="#SIFT特征" class="headerlink" title="SIFT特征"></a>SIFT特征</h3><p>SIFT的全称是Scale Invariant Feature Transform，尺度不变特征变换(物体怎么转，人都能识别)。SIFT特征对旋转、尺度缩放、亮度变化等保持不变性，是一种非常稳定的局部特征。</p><p>有4个主要步骤</p><p>1、尺度空间的极值检测 搜索所有尺度空间上的图像，通过高斯微分函数来识别潜在的对尺度和选择不变的兴趣点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$$$L(x,y,σ)=G(x,y,σ)∗I(x,y)$</span><br><span class="line"></span><br><span class="line">为了有效的在尺度空间检测到稳定的关键点，提出了高斯差分尺度空间（DOG scale-space）。利用不同尺度的高斯差分核与图像卷积生成。构造高斯差分尺度空间(DOG scale-space): </span><br><span class="line">$$D(x,y,σ)=(G(x,y,kσ)−G(x,y,σ))∗I(x,y)=L(x,y,kσ)−L(x,y,σ)$$</span><br><span class="line"></span><br><span class="line">σ 是尺度坐标。σ大小决定图像的平滑程度，大尺度对应图像的概貌特征，小尺度对应图像的细节特征。大的σ值对应粗糙尺度(低分辨率)，反之，对应精细尺度(高分辨率)。</span><br><span class="line"></span><br><span class="line">对于一幅图像I，建立其在不同尺度(scale)的图像,后面每个采样都是原图的1/4倍。</span><br><span class="line"></span><br><span class="line">每个点都要与邻域的点，上下相邻尺度的点做比较（9+8+9）26个点作比较（以确保在尺度空间和二维图像空间都检测到极值点）。一个点如果在DOG尺度空间本层以及上下两层的26个领域中是最大或最小值时，就认为该点是图像在该尺度下的一个特征点</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.csdn.net/20160411162902180" alt=""></p><p>2、特征点定位 在每个候选的位置上，通过一个拟合精细模型来确定位置尺度，关键点的选取依据他们的稳定程度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">拟和三维二次函数以精确确定关键点的位置和尺度，同时去除低对比度的关键点和不稳定的边缘响应点(因为DoG算子会产生较强的边缘响应)，以增强匹配稳定性、提高抗噪声能力</span><br></pre></td></tr></table></figure></p><p>用Harris Corner检测<br><a href="https://blog.csdn.net/ws_20100/article/details/51122322" target="_blank" rel="noopener">参考文章</a></p><p>3、特征方向赋值 基于图像局部的梯度方向，分配给每个关键点位置一个或多个方向，后续的所有操作都是对于关键点的方向、尺度和位置进行变换，从而提供这些特征的不变性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个特征点计算一个方向，依照这个方向做进一步的计算， *利用关键点邻域像素的梯度方向分布特性为每个关键点指定方向参数，使算子具备旋转不变性。</span><br></pre></td></tr></table></figure></p><p>$$m(x,y)=(L(x+1,y)−L(x−1,y))2+(L(x,y+1)−L(x,y−1))2$$<br>$$√θ(x,y)=atan2(L(x,y+1)−L(x,y−1)L(x+1,y)−L(x−1,y)$$<br>每个关键点有三个信息：位置、所处尺度、方向。由此可以确定一个SIFT特征区域。<br><img src="https://img-blog.csdn.net/20160413110610471" alt="直方图"><br>4、特征点描述 在每个特征点周围的邻域内，在选定的尺度上测量图像的局部梯度，这些梯度被变换成一种表示，这种表示允许比较大的局部形状的变形和光照变换。</p><blockquote><p>高斯函数是唯一可行的尺度空间核</p></blockquote><h3 id="尺度空间"><a href="#尺度空间" class="headerlink" title="尺度空间"></a>尺度空间</h3><p>多分辨率图像金字塔:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、对原始图像进行平滑</span><br><span class="line">2、对处理后的图像进行降采样（通常是水平、垂直方向的1/2）降采样后得到一系列不断尺寸缩小的图像。显然，一个传统的金字塔中，每一层的图像是其上一层图像长、高的各一半。多分辨率的图像金字塔虽然生成简单，但其本质是降采样，图像的局部特征则难以保持，也就是无法保持特征的尺度不变性。</span><br></pre></td></tr></table></figure></p><p>高斯尺度空间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">图像的模糊程度来模拟人在距离物体由远到近时物体在视网膜上成像过程，距离物体越近其尺寸越大图像也越模糊，这就是高斯尺度空间，使用不同的参数模糊图像（分辨率不变）</span><br><span class="line"></span><br><span class="line">图像和高斯函数进行卷积运算，图像模糊，使用不同的“高斯核”可得到不同模糊程度的图像</span><br><span class="line"></span><br><span class="line">L(x,y,σ)=G(x,y,σ)∗I(x,y)</span><br><span class="line"></span><br><span class="line">其中G(x,y,σ)是高斯核函数</span><br><span class="line">G(x,y,σ)=（1/2Πσ^2）e^((x^2+y^2)/(2σ^2))</span><br></pre></td></tr></table></figure></p><p>构建尺度空间的目的是为了检测出在不同的尺度下都存在的特征点，而检测特征点较好的算子是Δ^2G(高斯拉普拉斯,LoG）</p><h3 id="DoG特征"><a href="#DoG特征" class="headerlink" title="DoG特征"></a>DoG特征</h3><p>使用LoG虽然能较好的检测到图像中的特征点，但是其运算量过大，通常可使用DoG（差分高斯，Difference of Gaussina）来近似计算LoG。</p><p>DOG可以看作为LOG的一个近似，但是它比LOG的效率更高。<br>设k为相邻两个高斯尺度空间的比例因子，则DoG的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D(x,y,σ)=[G(x,y,kσ)−G(x,y,σ)]∗I(x,y)=L(x,y,kσ)−L(x,y,σ)</span><br></pre></td></tr></table></figure><p>L(x,y,σ) 是图像的高斯尺度空间<br>将相邻的两个高斯空间的图像相减就得到了DoG的响应图像</p><h3 id="Harris角点特征提取"><a href="#Harris角点特征提取" class="headerlink" title="Harris角点特征提取"></a>Harris角点特征提取</h3><font color="red">Harris角点检测是一种基于图像灰度的一阶导数矩阵检测方法。检测器的主要思想是局部自相似性/自相关性，即在某个局部窗口内图像块与在各个方向微小移动后的窗口内图像块的相似性。</font><blockquote><p>1、角点可以是两个边缘的角点；<br><br>2、角点是邻域内具有两个主方向的特征点；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">人眼对角点的识别通常是在一个局部的小区域或小窗口完成的。如果在各个方向上移动这个特征的小窗口，窗口内区域的灰度发生了较大的变化，那么就认为在窗口内遇到了角点。如果这个特定的窗口在图像各个方向上移动时，窗口内图像的灰度没有发生变化，那么窗口内就不存在角点；如果窗口在某一个方向移动时，窗口内图像的灰度发生了较大的变化，而在另一些方向上没有发生变化，那么，窗口内的图像可能就是一条直线的线段。</span><br></pre></td></tr></table></figure></p></blockquote><p>$$ x^{y^z}=(1+{\rm e}^x)^{-2xy^w} $$</p><p>$$sqrt()$$</p><blockquote><p>结论：1、增大α的值，将减小角点响应值R，降低角点检测的灵性，减少被检测角点的数量；减小α值，将增大角点响应值R，增加角点检测的灵敏性，增加被检测角点的数量。<br><br>2、Harris角点检测算子对亮度和对比度的变化不敏感<br><br>3、Harris角点检测算子具有旋转不变性<br><br>4、Harris角点检测算子不具有尺度不变性<br></p></blockquote><p><a href="https://blog.csdn.net/ws_20100/article/details/51122322" target="_blank" rel="noopener">参考这个就完事了</a></p><h3 id="局部特征"><a href="#局部特征" class="headerlink" title="局部特征"></a>局部特征</h3><p>不管原图尺度是多少，在包含了所有尺度的尺度空间下都能找到那些稳定的极值点，这样就做到了尺度不变！</p><blockquote><p>高斯函数是唯一可行的尺度空间核<br>比如说一张美女图片，想要框出帽子的信息，图像尺寸小时框要这么大，图像尺寸大时，框也要相应调大：</p></blockquote><p>尺度不变性：<br>$$L(x,y,σ)=G(x,y,σ)*I(x,y)$$</p><p>为了有效的在尺度空间检测到稳定的关键点，提出了高斯差分尺度空间（DOG scale-space）。利用不同尺度的高斯差分核与图像卷积生成。构造高斯差分尺度空间(DOG scale-space):<br>$$D(x,y,σ)=(G(x,y,kσ)-G(x,y,σ))*I(x,y)=L(x,y,kσ)-L(x,y,σ)$$</p><p>σ 是尺度坐标。σ大小决定图像的平滑程度，大尺度对应图像的概貌特征，小尺度对应图像的细节特征。大的σ值对应粗糙尺度(低分辨率)，反之，对应精细尺度(高分辨率)。</p><p>旋转不变性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Lowe采用的方法是在生成描述子前将图片旋转到一个特定的方向上，这个方向是根据图片内容得到的，具体就是用在某个半径大小的圆内的像素的梯度信息。</span><br><span class="line">sigma取的是1.5*&lt;scale of key point&gt;,r取3*sigma</span><br><span class="line">将图片先旋转到主方向，这个方向由于是用相同的信息得到的，所以总是指向同一方。</span><br></pre></td></tr></table></figure><p>抵抗噪声：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DoG得到极值点后，去除低对比度的点的点舍弃,在确定主方向和生成描述子时都将梯度模值加进行加权，即是噪声影响了部分点，经过加权统计会抑制变化，不会对全局造成太大影响</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/u014485485/article/details/78681086?locationNum=1&amp;fps=1" target="_blank" rel="noopener">参考文章</a></p><h3 id="OpenCV代码"><a href="#OpenCV代码" class="headerlink" title="OpenCV代码"></a>OpenCV代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">// opencv_empty_proj.cpp : 定义控制台应用程序的入口点。</span><br><span class="line">//</span><br><span class="line"> </span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &lt;opencv2/opencv.hpp&gt;</span><br><span class="line">#include &lt;opencv2/features2d/features2d.hpp&gt;</span><br><span class="line">#include&lt;opencv2/nonfree/nonfree.hpp&gt;</span><br><span class="line">#include&lt;opencv2/legacy/legacy.hpp&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using namespace cv;</span><br><span class="line"> </span><br><span class="line">int _tmain(int argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    const char* imagename = &quot;img.jpg&quot;;</span><br><span class="line">  </span><br><span class="line">    //从文件中读入图像</span><br><span class="line">    Mat img = imread(imagename);</span><br><span class="line">    Mat img2=imread(&quot;img2.jpg&quot;);</span><br><span class="line"> </span><br><span class="line">    //如果读入图像失败</span><br><span class="line">    if(img.empty())</span><br><span class="line">    &#123;</span><br><span class="line">            fprintf(stderr, &quot;Can not load image %s\n&quot;, imagename);</span><br><span class="line">            return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(img2.empty())</span><br><span class="line">    &#123;</span><br><span class="line">            fprintf(stderr, &quot;Can not load image %s\n&quot;, imagename);</span><br><span class="line">            return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    //显示图像</span><br><span class="line">    imshow(&quot;image before&quot;, img);</span><br><span class="line">    imshow(&quot;image2 before&quot;,img2);</span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    //sift特征检测</span><br><span class="line">    SiftFeatureDetector  siftdtc;</span><br><span class="line">    vector&lt;KeyPoint&gt;kp1,kp2;</span><br><span class="line"> </span><br><span class="line">    siftdtc.detect(img,kp1);</span><br><span class="line">    Mat outimg1;</span><br><span class="line">    drawKeypoints(img,kp1,outimg1);</span><br><span class="line">    imshow(&quot;image1 keypoints&quot;,outimg1);</span><br><span class="line">    KeyPoint kp;</span><br><span class="line"> </span><br><span class="line">    vector&lt;KeyPoint&gt;::iterator itvc;</span><br><span class="line">    for(itvc=kp1.begin();itvc!=kp1.end();itvc++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;angle:&quot;&lt;&lt;itvc-&gt;angle&lt;&lt;&quot;\t&quot;&lt;&lt;itvc-&gt;class_id&lt;&lt;&quot;\t&quot;&lt;&lt;itvc-&gt;octave&lt;&lt;&quot;\t&quot;&lt;&lt;itvc-&gt;pt&lt;&lt;&quot;\t&quot;&lt;&lt;itvc-&gt;response&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    siftdtc.detect(img2,kp2);</span><br><span class="line">    Mat outimg2;</span><br><span class="line">    drawKeypoints(img2,kp2,outimg2);</span><br><span class="line">    imshow(&quot;image2 keypoints&quot;,outimg2);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    SiftDescriptorExtractor extractor;</span><br><span class="line">    Mat descriptor1,descriptor2;</span><br><span class="line">    BruteForceMatcher&lt;L2&lt;float&gt;&gt; matcher;</span><br><span class="line">    vector&lt;DMatch&gt; matches;</span><br><span class="line">    Mat img_matches;</span><br><span class="line">    extractor.compute(img,kp1,descriptor1);</span><br><span class="line">    extractor.compute(img2,kp2,descriptor2);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    imshow(&quot;desc&quot;,descriptor1);</span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;descriptor1&lt;&lt;endl;</span><br><span class="line">    matcher.match(descriptor1,descriptor2,matches);</span><br><span class="line"> </span><br><span class="line">    drawMatches(img,kp1,img2,kp2,matches,img_matches);</span><br><span class="line">    imshow(&quot;matches&quot;,img_matches);</span><br><span class="line"> </span><br><span class="line">    //此函数等待按键，按键盘任意键就返回</span><br><span class="line">    waitKey();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-图像矩阵变换"><a href="#2-图像矩阵变换" class="headerlink" title="2 图像矩阵变换"></a>2 图像矩阵变换</h2><p>基本的二维变换可包括缩放、旋转、扭曲，和平移四种<br></p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/juzhen_1.png" alt=""></p><p>几何运算则可以转换为一些基本的矩阵运算<br></p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/juzhen_2.png" alt=""></p><p>平移运算不是线性的,使用矩阵乘法再使用矩阵加法来完成此操作<br><br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/juzhen_3.png" alt=""></p><p>综合这几种基本运算，数学家们将其统一为一个3*3矩阵，存储形式<br><br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/juzhen_4.png" alt=""></p><p>仿射变换的矩阵的第三列总是（0，0，1），在存储矩阵的时候，大多只存成一个2*3的数组。</p><blockquote><p>复合变换是有顺序的，一般说来，先旋转、再缩放、然后平移</p></blockquote><h2 id="3-纹理特征"><a href="#3-纹理特征" class="headerlink" title="3 纹理特征"></a>3 纹理特征</h2><h3 id="LBP图像特征"><a href="#LBP图像特征" class="headerlink" title="LBP图像特征"></a>LBP图像特征</h3><p>图像处理之特征提取（二）之LBP特征简单梳理<br><br><a href="https://blog.csdn.net/coming_is_winter/article/details/72859957" target="_blank" rel="noopener">https://blog.csdn.net/coming_is_winter/article/details/72859957</a><br><br><a href="https://blog.csdn.net/zouxy09/article/details/7929531" target="_blank" rel="noopener">https://blog.csdn.net/zouxy09/article/details/7929531</a><br><br>LBP特征理解。<br><br><a href="http://blog.csdn.net/hqh45/article/details/24501097" target="_blank" rel="noopener">http://blog.csdn.net/hqh45/article/details/24501097</a><br>LBP（Local Binary Pattern，局部二值模式）是一种用来描述图像局部纹理特征的算子；它具有旋转不变性和灰度不变性等显著的优点。它是首先由T. Ojala, M.Pietikäinen, 和 D. Harwood 在1994年提出，用于纹理特征提取。而且，提取的特征是图像的局部的纹理特征；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lbp理论：</span><br><span class="line">原始的LBP算子定义为在3*3的窗口内，以窗口中心像素为阈值，将相邻的8个像素的灰度值与其进行比较，若周围像素值大于中心像素值，则该像素点的位置被标记为1，否则为0。这样，3*3邻域内的8个点经比较可产生8位二进制数（通常转换为十进制数即LBP码，共256种），即得到该窗口中心像素点的LBP值，并用这个值来反映该区域的纹理信息。</span><br></pre></td></tr></table></figure><p>圆形LBP算子： 半径为R</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基本的 LBP算子的最大缺陷在于它只覆盖了一个固定半径范围内的小区域，这显然不能满足不同尺寸和频率纹理的需要。为了适应不同尺度的纹理特征，并达到灰度和旋转不变性的要求，Ojala等对 LBP 算子进行了改进，将 3×3邻域扩展到任意邻域，并用圆形邻域代替了正方形邻域，改进后的 LBP 算子允许在半径为 R 的圆形邻域内有任意多个像素点。从而得到了诸如半径为R的圆形区域内含有P个采样点的LBP算子；</span><br></pre></td></tr></table></figure><p>即不断旋转圆形邻域得到一系列初始定义的 LBP值，取其最小值作为该邻域的 LBP 值。</p><h3 id="灰度共生矩阵（GLCM，Gray-Level-Co-occurrence-Matrix）"><a href="#灰度共生矩阵（GLCM，Gray-Level-Co-occurrence-Matrix）" class="headerlink" title="灰度共生矩阵（GLCM，Gray-Level Co-occurrence Matrix）"></a>灰度共生矩阵（GLCM，Gray-Level Co-occurrence Matrix）</h3><p>概念：</p><blockquote><p>灰度共生矩阵是涉及像素距离和角度的矩阵函数，它通过计算图像中一定距离和一定方向的两点灰度之间的相关性，来反映图像在<font color="red">方向、间隔、变化幅度及快慢</font>上的综合信息。<br><br>灰度直方图是对图像上单个像素具有某个灰度进行统计的结果，而<font color="red">灰度共生矩阵是对图像上保持某距离的两像素分别具有某灰度的状况进行统计得到的。</font></p></blockquote><p>含义：<br>以（1，1）点为例，GLCM（1，1）值为1说明左侧原图只有一对灰度为1的像素水平相邻。GLCM（1，2）值为2，是因为原图有两对灰度为1和2的像素水平相邻。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">矩阵</span><br><span class="line">|1 2 1|</span><br><span class="line">|2 2 2| </span><br><span class="line">|1 2 2|</span><br><span class="line">对应GLMC矩阵（最大是2，所以是2*2矩阵）</span><br><span class="line"></span><br><span class="line">GLCM矩阵:</span><br><span class="line">  1 2</span><br><span class="line">1|0 2| </span><br><span class="line">2|1 6|</span><br><span class="line">0(1,1)相邻， 2(1,2)水平相邻， 2(2,1)垂直相邻， 6(2,2)相邻</span><br></pre></td></tr></table></figure><p>灰度共生矩阵的特征</p><p>1) 角二阶矩（Angular Second Moment, ASM)<br><br>公式：$ASM = sum(p(i,j)^2)$，其中  $p(i,j) $表示归一后的灰度共生矩阵<br>意义：角二阶矩是图像灰度分布均匀程度和纹理粗细的一个度量，当图像纹理绞细致、灰度分布均匀时，能量值较大，反之，较小。<br></p><font color="red">结论：值大，灰度分布均匀</font><p>2) 熵（Entropy, ENT)<br><br>公式：$ENT=sum[-p(i,j)log(p(i,j))] $<br>意义：描述图像具有的信息量的度量，表明图像的复杂程度，当复杂程度高时，熵值较大，反之则较小。<br></p><font color="red">结论：值大，复杂程度高</font><p>3) 反差分矩阵（Inverse Differential Moment, IDM)<br>公式：$IDM=sum[p(i,j)/(1+(i-j)^2)]$<br>意义：反映了纹理的清晰程度和规则程度，纹理清晰、规律性较强、易于描述的，值较大；杂乱无章的，难于描述的，值较小。</p><font color="red">结论：值大，纹理清晰、规律性较强</font><h3 id="Gabor小波"><a href="#Gabor小波" class="headerlink" title="Gabor小波"></a>Gabor小波</h3><p>Gabor函数是一个用于边缘提取的线性滤波器</p><p>作用：<br>Gabor小波可以方便的提取图像在<font color="red">各个尺度和方向上的纹理信息</font>，同时在一定程度上降低了图像中光照变化和噪声的影响。<br>提取目标的<font color="red">局部空间和频率域信息</font>方面具有良好的特性。<br><br>特点：<br>1、Gabor小波对于图像的边缘敏感<br>2、对光照不敏感<br>3、对图像旋转有一定适应性</p><h5 id="灰度共生矩阵opencv代码："><a href="#灰度共生矩阵opencv代码：" class="headerlink" title="灰度共生矩阵opencv代码："></a>灰度共生矩阵opencv代码：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">// 0°灰度共生矩阵</span><br><span class="line">void getGLCM0(Mat&amp; src, Mat&amp; dst, int gray_level)// 0度灰度共生矩阵</span><br><span class="line">&#123;</span><br><span class="line">CV_Assert(1 == src.channels());</span><br><span class="line"> </span><br><span class="line">int height = src.rows;</span><br><span class="line">int width = src.cols;</span><br><span class="line"> </span><br><span class="line">dst.create(gray_level, gray_level, CV_32SC1);</span><br><span class="line">dst = Scalar::all(0);</span><br><span class="line"> </span><br><span class="line">for (int i = 0; i &lt; height; i++)</span><br><span class="line">&#123;</span><br><span class="line">int*srcdata = src.ptr&lt;int&gt;(i);</span><br><span class="line">for (int j = 0; j &lt; width - 1; j++)</span><br><span class="line">&#123;</span><br><span class="line">// 同样的像素对，水平相邻</span><br><span class="line">int rows = srcdata[j];</span><br><span class="line">int cols = srcdata[j + 1];</span><br><span class="line">dst.ptr&lt;int&gt;(rows)[cols]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 90°灰度共生矩阵</span><br><span class="line">void getGLCM90(Mat&amp; src, Mat&amp; dst, int gray_level)</span><br><span class="line">&#123;</span><br><span class="line">CV_Assert(1 == src.channels());</span><br><span class="line"> </span><br><span class="line">int height = src.rows;</span><br><span class="line">int width = src.cols;</span><br><span class="line"> </span><br><span class="line">dst = Mat(gray_level, gray_level, CV_32SC1, Scalar(0));</span><br><span class="line"> </span><br><span class="line">for (int i = 0; i &lt; height - 1; i++)</span><br><span class="line">&#123;</span><br><span class="line">int*srcdata = src.ptr&lt;int&gt;(i);</span><br><span class="line">int*srcdata1 = src.ptr&lt;int&gt;(i + 1);</span><br><span class="line">for (int j = 0; j &lt; width; j++)</span><br><span class="line">&#123;</span><br><span class="line">// 同样的像素对，垂直相邻</span><br><span class="line">int rows = srcdata[j];</span><br><span class="line">int cols = srcdata1[j];</span><br><span class="line">dst.ptr&lt;int&gt;(rows)[cols]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 45°灰度共生矩阵</span><br><span class="line">void getGLCM45(Mat&amp; src, Mat&amp; dst, int gray_level)</span><br><span class="line">&#123;</span><br><span class="line">CV_Assert(1 == src.channels());</span><br><span class="line"> </span><br><span class="line">int height = src.rows;</span><br><span class="line">int width = src.cols;</span><br><span class="line"> </span><br><span class="line">dst = Mat(gray_level, gray_level, CV_32SC1, Scalar(0));</span><br><span class="line"> </span><br><span class="line">for (int i = 0; i &lt; height - 1; i++)</span><br><span class="line">&#123;</span><br><span class="line">int*srcdata = src.ptr&lt;int&gt;(i);</span><br><span class="line">int*srcdata1 = src.ptr&lt;int&gt;(i + 1);</span><br><span class="line">for (int j = 0; j &lt; width - 1; j++)</span><br><span class="line">&#123;</span><br><span class="line">// 同样的像素对，45°相邻</span><br><span class="line">int rows = srcdata[j];</span><br><span class="line">int cols = srcdata1[j + 1];</span><br><span class="line">dst.ptr&lt;int&gt;(rows)[cols]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 135°灰度共生矩阵</span><br><span class="line">void getGLCM135(Mat&amp; src, Mat&amp; dst, int gray_level)</span><br><span class="line">&#123;</span><br><span class="line">CV_Assert(1 == src.channels());</span><br><span class="line"> </span><br><span class="line">int height = src.rows;</span><br><span class="line">int width = src.cols;</span><br><span class="line"> </span><br><span class="line">dst = Mat(gray_level, gray_level, CV_32SC1, Scalar(0));</span><br><span class="line"> </span><br><span class="line">for (int i = 0; i &lt; height - 1; i++)</span><br><span class="line">&#123;</span><br><span class="line">int*srcdata = src.ptr&lt;int&gt;(i);</span><br><span class="line">int*srcdata1 = src.ptr&lt;int&gt;(i + 1);</span><br><span class="line">for (int j = 1; j &lt; width; j++)</span><br><span class="line">&#123;</span><br><span class="line">// 同样的像素对，135°相邻</span><br><span class="line">int rows = srcdata[j];</span><br><span class="line">int cols = srcdata1[j - 1];</span><br><span class="line">dst.ptr&lt;int&gt;(rows)[cols]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 计算特征值</span><br><span class="line">void featureGLCM(Mat&amp;src, double&amp; Asm, double&amp; Ent, double&amp; Con, double&amp; Idm)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">CV_Assert(src.channels() == 1);</span><br><span class="line"></span><br><span class="line">int height = src.rows;</span><br><span class="line">int width = src.cols;</span><br><span class="line">int total = 0;</span><br><span class="line"> </span><br><span class="line">//求图像所有像素的灰度值的和</span><br><span class="line">for (int i = 0; i &lt; height; i++)</span><br><span class="line">&#123;</span><br><span class="line">int*srcdata = src.ptr&lt;int&gt;(i);</span><br><span class="line">for (int j = 0; j &lt; width; j++)</span><br><span class="line">&#123;</span><br><span class="line">total += srcdata[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//图像每一个像素的的值除以像素总和</span><br><span class="line">Mat mean;</span><br><span class="line">mean.create(height, width, CV_64FC1);</span><br><span class="line">for (int i = 0; i &lt; height; i++)</span><br><span class="line">&#123;</span><br><span class="line">int*srcdata = src.ptr&lt;int&gt;(i);</span><br><span class="line">double*copydata = mean.ptr&lt;double&gt;(i);</span><br><span class="line">for (int j = 0; j &lt; width; j++)</span><br><span class="line">&#123;</span><br><span class="line">copydata[j] = (double)srcdata[j] / (double)total;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">for (int i = 0; i &lt; height; i++)</span><br><span class="line">&#123;</span><br><span class="line">double*srcdata = mean.ptr&lt;double&gt;(i);</span><br><span class="line">for (int j = 0; j &lt; width; j++)</span><br><span class="line">&#123;</span><br><span class="line">// 能量</span><br><span class="line">Asm += srcdata[j] * srcdata[j];</span><br><span class="line"> </span><br><span class="line">// 熵(Entropy) </span><br><span class="line">if (srcdata[j]&gt;0)</span><br><span class="line">Ent -= srcdata[j] * log(srcdata[j]);</span><br><span class="line"> </span><br><span class="line">// 对比度</span><br><span class="line">Con += (double)(i - j)*(double)(i - j)*srcdata[j];</span><br><span class="line"> </span><br><span class="line">// 逆差矩</span><br><span class="line">Idm += srcdata[j] / (1 + (double)(i - j)*(double)(i - j));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-颜色特征"><a href="#4-颜色特征" class="headerlink" title="4 颜色特征"></a>4 颜色特征</h2><h3 id="颜色直方图"><a href="#颜色直方图" class="headerlink" title="颜色直方图"></a>颜色直方图</h3><p>OpenCV之颜色空间:</p><p>颜色空间RGB（Red 红色，Green 绿色，Blue 蓝色）</p><p>R的取值范围：0-255</p><p>G的取值范围：0-255</p><p>B的取值范围：0-255</p><p>颜色空间HSV （Hue 色相，Saturation 饱和度，intensity 亮度）</p><p>H的取值范围：0-179</p><p>S的取值范围：0-255</p><p>V的取值范围：0-255</p><p>颜色空间HLS (Hue 色相，lightness 亮度，Saturation 饱和度)</p><p>H的取值范围：0-179</p><p>L的取值范围：0-255</p><p>S的取值范围：0-255</p><h3 id="颜色矩"><a href="#颜色矩" class="headerlink" title="颜色矩"></a>颜色矩</h3><p>这种方法的数学基础在于图像中任何的颜色分布均可以用它的矩来表示。此外，由于颜色分布信息主要集中在低阶矩中，因此仅采用颜色的一阶矩（mean）、二阶矩（variance）和三阶矩（skewness）就足以表达图像的颜色分布。与颜色直方图相比，该方法的另一个好处在于无需对特征进行向量化。<br>图像的颜色矩一共只需要9个分量（3个颜色分量，每个分量上3个低阶矩）<br>颜色矩常和其它特征结合使用，而且一般在使用其它特征前起到过滤缩小范围（narrow down）的作用。 </p><p>一阶矩(均值,mean),反映图像明暗程度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u=(1/N)sum(Pij)</span><br></pre></td></tr></table></figure><p>二阶矩(方差,viarance),反映图像颜色分布范围</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=sqrt(((1/N)sum(Pij-u)^2),2)</span><br></pre></td></tr></table></figure><p>三阶矩(斜度,skewness),反映图像颜色分布对称性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=sqrt(((1/N)sum(Pij-u)^3),3)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-局部特征&quot;&gt;&lt;a href=&quot;#1-局部特征&quot; class=&quot;headerlink&quot; title=&quot;1 局部特征&quot;&gt;&lt;/a&gt;1 局部特征&lt;/h2&gt;&lt;p&gt;LOG,HOG,DOG微分算子在近圆的斑点检测方面效果很好&lt;/p&gt;
    
    </summary>
    
    
      <category term="图像处理" scheme="https://www.littlefeng.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="特征提取" scheme="https://www.littlefeng.com/tags/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/"/>
    
  </entry>
  
</feed>
